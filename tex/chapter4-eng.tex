
\chapter{Design of Markdown parser}

\lstinline{Markdown} is a lightweight language, widely used for small scale 
writing. It comes in handy when regular markup languages such as 
\lstinline{HTML} and~\LaTeX~are considered an overkill.~\lstinline{Markdown}
is popular in IT community, for instance it is extensively used on source code 
repositories hosting web sites, like \lstinline{GitHub}~\cite{github}.

\section{Markdown Syntax}

  In contrast with~\lstinline{HTML} or~\lstinline{XML},~\lstinline{Markdown}
  doesn't have a standard. However, informal but comprehensive description of 
  syntax exists~\cite{markdownSyntax}. There are also several enhanced versions, 
  such as, for example,~\lstinline{GitHub Flavoured Markdown}~\cite{GFM}.

  In this work a subset of~\lstinline{Markdown} syntax is considered, 
  specifically headers, paragraphs, unordered lists and block quotes. In addition, 
  source code may include~\LaTeX-blocks with formulae.   

\section{Parser}

  \lstinline{Haskell} programming language is know for its rich type system. 
  It provides facilities of algebraic data types (ADTs), that could be exploited 
  to conveniently express structure of abstract syntax tree (AST). Every 
  \lstinline{Document} is a list of blocks. Now, \lstinline{Block} is a sum type, 
  which means that each of its data constructors represents some 
  \lstinline{Markdown}-block.     

  \begin{figure}[t]
  \begin{lstlisting}
  type Document = [Block]

  data Block = Blank
             | Header (Int,Line)
             | Paragraph [Line]
             | UnorderedList [Line]
             | BlockQuote [Line]
    deriving (Show,Eq)

  data Line = Empty | NonEmpty [Inline]
    deriving (Show,Eq)

  data Inline = Plain String
              | Bold String
              | Italic String
              | Monospace String
    deriving (Show,Eq)
  \end{lstlisting}
  \caption{Types of \lstinline{Markdown} abstract syntactic tree}
  \label{listing:MarkdownADT}
  \end{figure}

  Let's take a closer look at types from listing~\ref{listing:MarkdownADT}.
  \lstinline{Block} is either empty block, or header, or paragraph, or
  unordered list, or block quote. Most blocks is essentially a list of lines.
  Every line is a collection of inline elements that are treated differently 
  based on its style. Listing~\ref{listing:MarkdownInline} contains parsers for 
  line and inline elements, parsers \lstinline{bold}, \lstinline{italic} and 
  \lstinline{plain} are similar to \lstinline{monospace} and are omitted for 
  the sake of briefness.

  Implementation of \lstinline{Markdown} parsers heavily relies on base of 
  combinators, that have been described in chapter 3. It won't be redundant to
  remind types of those combinators (see listing~\ref{listing:ParserCombinators}).   

  \begin{figure}[h]
  \begin{lstlisting}
  many :: Parser t a -> Parser t [a]

  sepby :: Parser t a -> Parser t b -> Parser t [a]

  bracket :: Parser t a -> Parser t b -> Parser t c -> Parser t b
  \end{lstlisting}
  \caption{Type signatures of base parser combinators}
  \label{listing:ParserCombinators}
  \end{figure}

  \begin{enumerate}
    \item \lstinline{many} parses a list of tokens which satisfy its argument.
    \item \lstinline{sepby} parses a sequence of tokens which satisfy its first 
    argument and separated by tokens which satisfy second one.
    \item \lstinline{bracket} parses tokens which satisfies its third argument 
    and enclosed by tokens which satisfy first and third one respectively.
  \end{enumerate}

  \begin{figure}[t]
  \begin{lstlisting}
  line :: TM.TextualMonoid t => Parser t Line
  line = emptyLine `mplus` nonEmptyLine

  emptyLine :: TM.TextualMonoid t => Parser t Line
  emptyLine = many (sat wspaceOrTab) >> char '\n' >> return Empty

  nonEmptyLine :: TM.TextualMonoid t => Parser t Line
  nonEmptyLine = do
    many (sat wspaceOrTab)
    l <- sepby1 (bold <|> italic <|>
                 plain <|> monospace) (many (char ' '))
    many (sat wspaceOrTab)
    char '\n'
    return . NonEmpty $ l

  monospace :: TM.TextualMonoid t => Parser t Inline
  monospace = do
    txt <- bracket (char '`') sentence (char '`')
    p   <- many punctuation
    return . Monospace $ txt ++ p
  \end{lstlisting}
  \caption{Parsers of inline elements}
  \label{listing:MarkdownInline}
  \end{figure}

  Being able to to correctly parse both lines and inline elements, it's 
  time to get to block parsers. Listing~\ref{listing:MarkdownHeader} contains 
  parser for header and~\ref{listing:markdownUlist} for unordered list. Parsers 
  for the rest of blocks may be constructed in a similar way.

  \begin{figure}[t]
  \begin{lstlisting}
  header :: TM.TextualMonoid t => Parser t Block
  header = do
    hashes <- token (some (char '#'))
    text <- nonEmptyLine
    return $ Header (length hashes,text)
  \end{lstlisting}
  \caption{Parsers for header}
  \label{listing:MarkdownHeader}
  \end{figure}

  \begin{figure}[t]
  \begin{lstlisting}
  unorderedList :: TM.TextualMonoid t => Parser t Block
  unorderedList = do
    items <- some (token bullet >> line)
    return . UnorderedList $ items
    where
      bullet :: TM.TextualMonoid t => Parser t Char
      bullet = char '*' <|> char '+' <|> char '-' >>= return
  \end{lstlisting}
  \caption{Parser for unordered list}
  \label{listing:markdownUlist}
  \end{figure}

  \lstinline{Markdown} language is also used for making notes during lectures 
  and talks, building documentation, and preparing assignments. Therefore, 
  \LaTeX~blocks seem as a helpful enhancement of a language. There almost no 
  additional work to be done here: it's needed to recognize a \LaTeX~block and 
  leave its contents unmodified, so could be later treated properly 
  by code generator.      

  \begin{figure}[h]
  \begin{lstlisting}
  blockMath :: TM.TextualMonoid t => Parser t Block
  blockMath =
    (bracket (string "$$") (some (sat (/= '$'))) (string "$$")) >>=
    return . Paragraph . (: []) . NonEmpty . (: []) . Plain .
      (\x -> "$$" ++ x ++ "$$")
  \end{lstlisting}
  \caption{Parser for \LaTeX-blocks}
  \label{listing:MarkdownLaTeX}
  \end{figure}

  Listing \ref{listing:MarkdownDoc} presents top-level parser for 
  \lstinline{Markdown}-document as a list of blocks.

  \begin{figure}[h]
  \begin{lstlisting}
  doc :: TM.TextualMonoid t => Parser t Document
  doc = many block
    where block = blank <|> header <|> paragraph <|>
                  unorderdList <|> blockquote <|> blockMath
  \end{lstlisting}
  \caption{Top-level parser for \lstinline{Markdown}-document}
  \label{listing:MarkdownDoc}
  \end{figure}

\section{HTML generation}

  Having an AST, code in any markup language could be generated. In this work, 
  \lstinline{HTML} has been chosen as a target language. One advantage of \lstinline{HTML} 
  is possibility of use of \lstinline{JavaScript}-libraries,
  such as \lstinline{MathJax}~\cite{mathJax} to render \LaTeX~blocks. 

  Code generation process follows structure of abstract syntactic tree: function
  \lstinline{serialize} generated code for list of blocs and collapses result to
  a single string. Every block type is handled by separate pattern matching clause 
  of~\lstinline{genBlock} function. Equally for lines elements and function 
  \lstinline{genLine}.

  Listing~\ref{listing:HTMLGen} displays simplified code generators: handlers 
  for some items are omitted for compactness.  

  \begin{figure}[h]
  \begin{lstlisting}
  serialize :: Document -> String
  serialize = concatMap genBlock

  genBlock :: Block -> String
  genBlock Blank = "\n"
  genBlock (Header h) =
    "<h" ++ s ++ ">" ++ genLine (snd h) ++ "</h" ++ s ++ ">" ++ "\n"
      where s = show (fst h)
  genBlock (UnorderedList l) =
    "<ul>" ++ concatMap ((++ "\n") . genOrderedListItem) l ++ "</ul>" ++ "\n"

  genLine :: Line -> String
  genLine Empty         = ""
  genLine (NonEmpty []) = genLine Empty ++ "\n"
  genLine (NonEmpty l)  = concatMap ((++ " ") . genInline) l

  genOrderedListItem :: Line -> String
  genOrderedListItem l = "<li>" ++ genLine l ++ "</li>"

  genInline :: Inline -> String
  genInline (Plain s) = s
  genInline (Monospace s) = "<code>" ++ s ++ "</code>"
  \end{lstlisting}
  \caption{\lstinline{HTML} markup generation}
  \label{listing:HTMLGen}
  \end{figure}

  This is, in brief, the process of~\lstinline{Markdown} parsing and \lstinline{HTML}
  code generation. Full source codes of parsers and code generator may be found 
  in~\lstinline{GitHub} repository~\cite{mdParse}.
