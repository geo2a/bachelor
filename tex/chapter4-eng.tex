
\chapter{Design of Markdown parser}

\lstinline{Markdown} is a lightweight language, widely used for small scale 
writing. It comes in handy when regular markup languages such as 
\lstinline{HTML} and \LaTeX are considered an overkill. \lstinline{Markdown}
is popular in IT community, for instance it is extensively used on 
\lstinline{GitHub}.

\section{Markdown Syntax}

  In contrast with \lstinline{HTML} or \lstinline{XML}, \lstinline{Markdown}
  doesn't have a standard. However, informal but comprehensive description of 
  syntax exists~\cite{markdownSyntax}. There are also several enhanced versions, 
  such as, for example, \lstinline{GitHub Flavored Markdown}.

  In this work a subset of \lstinline{Markdown} syntax is considered, 
  specifically headers, paragraphs, unordered lists and block quotes. In addition, 
  source code may include \LaTeX-blocks with formulae.   

\section{Parser}

  \lstinline{Haskell} programming language is know for its rich type system. It
  such gear as algebraic data types (ADTs), that could be exploited to conveniently 
  express structure of abstract syntax tree (AST). Every 
  \lstinline{Document} is a list of blocks. Now, 
  \lstinline{Block} is a sum type, which means that each of its data constructors 
  represents some \lstinline{Markdown}-block.     

  \begin{figure}[t]
  \begin{lstlisting}
  type Document = [Block]

  data Block = Blank
             | Header (Int,Line)
             | Paragraph [Line]
             | UnorderedList [Line]
             | BlockQuote [Line]
    deriving (Show,Eq)

  data Line = Empty | NonEmpty [Inline]
    deriving (Show,Eq)

  data Inline = Plain String
              | Bold String
              | Italic String
              | Monospace String
    deriving (Show,Eq)
  \end{lstlisting}
  \caption{Types of \lstinline{Markdown} abstract syntactic tree}
  \label{listing:MarkdownADT}
  \end{figure}

  Let's take a closer look at types from listing~\ref{listing:MarkdownADT}.
  \lstinline{Block} is either empty block, or header, or paragraph, or
  unordered list, or block quote. Most blocks is essentially a list of lines.
  Every line is a collection of inline elements that are treated differently 
  based on its style. Listing~\ref{listing:MarkdownInline} contains parsers for 
  line and inline elements, parsers \lstinline{bold}, \lstinline{italic} and 
  \lstinline{plain} are similar to \lstinline{monospace} and are omitted for 
  the sake of briefness.

  Implementation of \lstinline{Markdown} parsers heavily relies on base of 
  combinators, that have been described in chapter 3. It won't be a redundant to
  remind types of those combinators (see~\ref{listing:ParserCombinators}).   

  \begin{figure}[h]
  \begin{lstlisting}
  many :: Parser t a -> Parser t [a]

  sepby :: Parser t a -> Parser t b -> Parser t [a]

  bracket :: Parser t a -> Parser t b -> Parser t c -> Parser t b
  \end{lstlisting}
  \caption{Type signatures of base parser combinators}
  \label{listing:ParserCombinators}
  \end{figure}

  \begin{enumerate}
    \item \lstinline{many} parses a list of tokens which satisfy its parameter.
    \item \lstinline{sepby} parses a sequence of tokens which satisfy its second 
    argument первому параметру и разделённых токенами, удовлетворяющими
    его второму параметру.
    \item Комбинатор \lstinline{bracket} распознаёт токены, удовлетворяющие его
    третьему параметру и заключенные между токенами, удовлетворяющими первому и
    третьему параметру соответственно.
  \end{enumerate}

  \begin{figure}[t]
  \begin{lstlisting}
  line :: TM.TextualMonoid t => Parser t Line
  line = emptyLine `mplus` nonEmptyLine

  emptyLine :: TM.TextualMonoid t => Parser t Line
  emptyLine = many (sat wspaceOrTab) >> char '\n' >> return Empty

  nonEmptyLine :: TM.TextualMonoid t => Parser t Line
  nonEmptyLine = do
    many (sat wspaceOrTab)
    l <- sepby1 (bold <|> italic <|>
                 plain <|> monospace) (many (char ' '))
    many (sat wspaceOrTab)
    char '\n'
    return . NonEmpty $ l

  monospace :: TM.TextualMonoid t => Parser t Inline
  monospace = do
    txt <- bracket (char '`') sentence (char '`')
    p   <- many punctuation
    return . Monospace $ txt ++ p
  \end{lstlisting}
  \caption{Распознавание строк из строчных элементов.}
  \label{listing:MarkdownInline}
  \end{figure}

  Получив возможность распознавать строки и строчные элементы, можно приступить к реализации парсеров для блоков. В листинге~\ref{listing:MarkdownHeader} представлен парсер для заголовка, а в листинге~\ref{listing:markdownUlist} --- для неупорядоченного списка, парсеры для остальных блоков описываются схожим образом. Здесь следует сделать замечание, что текущая версия парсера не поддерживает вложенные списки, оформляемые в \lstinline{Markdown} с помощью отступов.

  \begin{figure}[t]
  \begin{lstlisting}
  header :: TM.TextualMonoid t => Parser t Block
  header = do
    hashes <- token (some (char '#'))
    text <- nonEmptyLine
    return $ Header (length hashes,text)
  \end{lstlisting}
  \caption{Парсер для заголовка}
  \label{listing:MarkdownHeader}
  \end{figure}

  \begin{figure}[t]
  \begin{lstlisting}
  unorderedList :: TM.TextualMonoid t => Parser t Block
  unorderedList = do
    items <- some (token bullet >> line)
    return . UnorderedList $ items
    where
      bullet :: TM.TextualMonoid t => Parser t Char
      bullet = char '*' <|> char '+' <|> char '-' >>= return
  \end{lstlisting}
  \caption{Парсер для неупорядоченного списка}
  \label{listing:markdownUlist}
  \end{figure}

  \lstinline{Markdown} применяется также для электронного конспектирования и
  оформления заданий. Полезным расширением грамматики \lstinline{Markdown}
  являются вставки математических формул в формате \LaTeX. Требуется распознать
  \LaTeX-блок и оставить его без изменений, чтобы при последующей генерации кода
  по абстрактному синтаксическому дереву можно было отобразить его соответствующим
  образом. Для этого служит парсер из листинга~\ref{listing:MarkdownLaTeX}.

  \begin{figure}[h]
  \begin{lstlisting}
  blockMath :: TM.TextualMonoid t => Parser t Block
  blockMath =
    (bracket (string "$$") (some (sat (/= '$'))) (string "$$")) >>=
    return . Paragraph . (: []) . NonEmpty . (: []) . Plain .
      (\x -> "$$" ++ x ++ "$$")
  \end{lstlisting}
  \caption{Парсер \LaTeX-блоков}
  \label{listing:MarkdownLaTeX}
  \end{figure}

  В листинге \ref{listing:MarkdownDoc} представлен парсер самого верхнего уровня,
  служащий для распознавания \lstinline{Markdown}-документа как списка блоков.

  \begin{figure}[h]
  \begin{lstlisting}
  doc :: TM.TextualMonoid t => Parser t Document
  doc = many block
    where block = blank <|> header <|> paragraph <|>
                  unorderdList <|> blockquote <|> blockMath
  \end{lstlisting}
  \caption{Парсер, распознающий \lstinline{Markdown}-документ}
  \label{listing:MarkdownDoc}
  \end{figure}

\section{Генерация HTML-кода}

  Имея абстрактное синтаксическое дерево \lstinline{Markdown}-документа можно
  сгенерировать по нему исходный текст на любом требуемом языке разметки.
  В качестве целевого был выбран язык разметри гипертекста \lstinline{HTML}, для рендеринга
  \LaTeX-вставок используется \lstinline{JavaScript}-библиотека
  \lstinline{MathJax}~\cite{mathJax}. Возможно построения генераторов и для
  других языков разметки.

  Генерация кода происходит от общего к частному. Функция \lstinline{serialize}
  генерирует код по списку блоков и конкатенирует результат. Генерация каждого
  блока производится функцией \lstinline{genBlock}, которая соответствующим
  образом обрабатывает все поддерживаемые виды блоков и генерирует нужный код.
  Строки и строчные элементы генерируются функциями \lstinline{genLine} и
  \lstinline{genInline} соответственно.

  В листинге~\ref{listing:HTMLGen} представлен сокращённый кодогенератор, опущена,
  для краткости, обработка некоторых блоков и строчных элементов, которая
  происходит аналогично представленным. Этот код служит демонстрацией
  выразительности, которая предоставляется сопоставлением с образцом и
  алгебраическими типами данных.

  \begin{figure}[h]
  \begin{lstlisting}
  serialize :: Document -> String
  serialize = concatMap genBlock

  genBlock :: Block -> String
  genBlock Blank = "\n"
  genBlock (Header h) =
    "<h" ++ s ++ ">" ++ genLine (snd h) ++ "</h" ++ s ++ ">" ++ "\n"
      where s = show (fst h)
  genBlock (UnorderedList l) =
    "<ul>" ++ concatMap ((++ "\n") . genOrderedListItem) l ++ "</ul>" ++ "\n"

  genLine :: Line -> String
  genLine Empty         = ""
  genLine (NonEmpty []) = genLine Empty ++ "\n"
  genLine (NonEmpty l)  = concatMap ((++ " ") . genInline) l

  genOrderedListItem :: Line -> String
  genOrderedListItem l = "<li>" ++ genLine l ++ "</li>"

  genInline :: Inline -> String
  genInline (Plain s) = s
  genInline (Monospace s) = "<code>" ++ s ++ "</code>"
  \end{lstlisting}
  \caption{Генерация \lstinline{HTML}}
  \label{listing:HTMLGen}
  \end{figure}

  Полный исходный код парсера \lstinline{Markdown}, кодогенератора, а также вспомогательной библиотеки комбинаторов парсеров доступен в репозитории~\cite{mdParse}.
