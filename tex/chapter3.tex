\chapter{Методы построения библиотек синтаксических анализаторов}

Вернёмся к простейшему типу для представления синтаксического анализатора 
(листинг~\ref{listing:basicParserType}). Парсер --- это функция, 
принимающая на вход строку символов и возвращающая список пар возможных вариантов  
разбора и неразобранных остатков входного потока. Пустой список результатов 
соответствует полностью неудачному разбору, а множество результатов --- 
неоднозначности.

\begin{figure}[h]
\begin{lstlisting}
type Parser a = String -> [(a,String)]
\end{lstlisting}
\caption{Тип Parser}
\label{listing:basicParserType}
\end{figure}

Типы вида Parser a можно рассматривать как вычисления с
определённым побочным эффектом. В данном случае эксплуатируется эффект 
недетерминизма вычислений, для выражения возможности неоднозначного разбора.
Для представления эффектов такого рода в языке~\lstinline{Haskell} используется
концепция монады~\cite{wadlerMonads}. В статье~\cite{monParsing} можно найти 
подробную информацию о свойствах таких парсеров, а также описание необходимых 
экземпляров классов типов.

Для расширения возможностей и повышения удобства синтаксического анализа можно расширять
набор эффектов функций-парсеров. Далее будут представлены методы построения библиотек
монадических комбинаторов парсеров с использованием двух подходов к контролю
вычислительных эффектов: трансформеров монад и расширяемых эффектов. 

\section{Синтаксические анализаторы на основе стека трансформеров монад}

  Трансформеры (преобразователи) монад --- концепция, позволяющая придать заданной 
  монаде свойства другой монады. Возможно многократное повторение этого преобразования, 
  порождающее стек монад, которые комбинирует вычислительных эффекты, привносимые 
  каждой отдельной монадой.

  В статье~\cite{monParsing} предлагается способ разложения типа из 
  листинга~\ref{listing:basicParserType} на стек из двух монад: монады для вычислений 
  с состоянием и списковой монады, обеспечивающей эффект недетерминизма. Таким образом, 
  тип приобретает вид, представленный в листинге~\ref{listing:monadStackParserType}.

  \begin{figure}[h]
  \begin{lstlisting}
  type Parser a = StateT String [] a
  \end{lstlisting}
  \caption{Парсер как простой стек монад}
  \label{listing:monadStackParserType}
  \end{figure}

  Концепция трансформеров монад позволяет добавлять к стеку различные монады, 
  предоставляющие различные полезные свойства: вычисления в конфигурируемом окружении, 
  потенциально ошибочные вычисления, ведение лога и другие. В разработанной автором 
  библиотеке монадических комбинаторов парсеров~\cite{mdParse} используется многоуровневый 
  стек монад, представленный в листинге~\ref{listing:hugeMonadStackParserType}. Это 
  представления парсера также является параметризованным типом входного потока.
  Типы~\lstinline{ParserState} и~\lstinline{ErrorReport} представляют собой 
  алгебраические типы данных для представления состояния парсера и возможной 
  ошибки разбора соответственно.

  \begin{figure}[h]
  \begin{lstlisting}
  newtype Parser t a = Parser (  
      StateT (ParserState t) (Either (ErrorReport t)) a
    ) deriving ( Functor, Applicative, Monad
               , MonadState (ParserState t)
               , MonadError (ErrorReport t)
               )
  \end{lstlisting}
  \caption{Парсер как стек монад}
  \label{listing:hugeMonadStackParserType}
  \end{figure}

  Самым низкоуровневым примитивом, на основе которого строятся все последующие 
  комбинаторы, является парсер, потребляющий из входного потока единственный элемент
  (листинг~\ref{listing:mtlParsersItem}).

  \begin{figure}[h]
  \begin{lstlisting}
  item :: TM.TextualMonoid t => Parser t Char
  item = do
    state  <- get
    let s = TM.splitCharacterPrefix . remainder $ state
    case s of 
      Nothing -> throwError (EmptyRemainder "item",state)
      Just (c,rest) -> do  
        let (c,rest) = fromJust s
        put (ParserState {position = updatePos (position state) c, remainder = rest})
        return c  
  \end{lstlisting}
  \caption{Потребление одного элемента входного потока парсером на основе трансформеров 
  монад}
  \label{listing:mtlParsersItem}
  \end{figure} 

  В листингах~\ref{listing:mtlParserSat} и~\ref{listing:mtlParserString} приведены ещё дав примера парсеров из разработанной библиотеки: 
  распознавание символа, удовлетворяющего предикату и заданной строки символов.

  \begin{figure}[h]
  \begin{lstlisting}
  sat :: TM.TextualMonoid t => (Char -> Bool) -> Parser t Char
  sat p = do
    state <- get
    x <- item `overrideError` (EmptyRemainder "sat")
    if p x then return x else 
      throwError (UnsatisfiedPredicate "general",state)
  \end{lstlisting}
  \caption{}
  \label{listing:mtlParserSat}
  \end{figure}

  \begin{figure}[h]
  \begin{lstlisting}
  string :: TM.TextualMonoid t => String -> Parser t String
  string s = do
    state <- get
    (mapM char s) `overrideError` 
      (UnsatisfiedPredicate ("string " ++ s))
  \end{lstlisting}
  \caption{}
  \label{listing:mtlParserString}
  \end{figure}

  Для осуществления разбора необходимо описать функцию, которая ``запускает''
  вычисление (листинг~\ref{listing:mtlParseRun}). При использовании трансформеров 
  монад порядок обработки вычислительных эффектов статически зафиксирован в 
  типе стека монад. 
  
  \begin{figure}[h]
  \begin{lstlisting}
parse :: TM.TextualMonoid t => 
  Parser t a -> t -> Either (ErrorReport t) (a,ParserState t)
parse (Parser p) s = 
  runStateT p (ParserState {remainder = s, position = initPos})
    where initPos = (1,1)
  \end{lstlisting}
  \caption{}
  \label{listing:mtlParseRun}
  \end{figure}


  Следует сказать, что концепция трансформеров монад имеет определённое удобство 
  для программирования благодаря своей зрелости и популярности. Однако, как уже
  обсуждалось ранее в разделе 1, этот подход обладает довольно низкой гибкостью, 
  не позволяет добавлять к стеку несколько однородных эффектов (например, два 
  трансформера~\lstinline{StateT}) без потери возможности автоматического 
  подъёма (~\lstinline{lift}) и требует описания большого числа экземпляров классов 
  типов. 

  Рассмотрим далее методы построения монадических комбинаторов парсеров, основанные
  на расширяемых эффектах --- альтернативному трансформерам монад подходу к управлению
  вычислительными эффектами.  

\section{Синтаксические анализаторы на основе расширяемых эффектов}

  Расширяемые эффекты, подробно описанные в статье~\cite{extEffects}, представляют
  собой альтернативный трансформерам монад подход к описанию вычислений с поблочными
  эффектами.

  Суть подхода заключается в аналогии между вычислительными эффектами и
  клиент-серверным взаимодействием. Код, который собирается породить некоторый
  побочный эффект: совершить ввод-вывод, бросить исключение и тому подобное должен
  отправить \emph{запрос} на обработку этого эффекта особой глобальной сущности
  --- менеджеру эффектов. Запрос описывает действие, которое необходимо
  произвести, а также функцию-продолжение (англ. \emph{continuation}) для
  возобновления работы после обработки запроса.

  При разработке прототипа библиотеки парсеров~\cite{extEffParsers}, основанной на расширяемых 
  эффектах, автором было принято следующее архитектурное решение: 
  не создавать специальный тип для парсера, а указывать необходимый набор эффектов 
  в ограничениях каждого отдельного комбинатора.

  В листинге~\ref{listing:extEffItem} приведён базовый примитив библиотеки, 
  функция --- потребляющая единственный символ из входного потока. 
  В типовой аннотации декларированы
  производимые функцией побочные эффекты: возможная неудача при разборе и 
  вычисление с состоянием. Рассмотрим эту типовую аннотацию подробнее. 
  Ограничение~\lstinline{Member Fail r} указывает, что набор 
  эффектов~\lstinline{r} должен включать в себя эффект~\lstinline{Fail}, а 
  результирующий тип функции~\lstinline{Eff r Char} означает, что данный 
  комбинатор является вычислением с побочными эффектами из набора~\lstinline{r},
  и порождает в качестве результата значение типа~\lstinline{Char}. 

  \begin{figure}[h]
  \begin{lstlisting}
item :: ( Member Fail r
        , Member (State String) r
        ) => Eff r Char
item = do
  s <- get
  case s of 
    [] -> die
    (x:xs) -> put xs >> return x 
  \end{lstlisting}
  \caption{Потребление одного элемента входного потока парсером на основе 
  расширяемых эффектов}
  \label{listing:extEffItem}
  \end{figure} 

  В целом, с точки зрения синтаксиса языка~\lstinlie{Haskell}, описание 
  комбинаторов с помощью расширяемых эффектов не сильно отличается от 
  подхода с трансформераи монад. Это достигается за счёт того, что 
  тип~\lstinline{Eff r a} является свободной монадой, построенной по открытому 
  объединения эффектов~\lstinline{r}, которое является функтором. Благодаря
  наличию экземпляра класса типов~\lstinline{Monad} для типа~\lstinline{Eff r a}
  возможно использование do-нотации и аппликативного стиля.

  \begin{figure}[h]
  \begin{lstlisting}
sat :: ( Member Fail r
       , Member (State String) r
       ) => (Char -> Bool) -> Eff r Char
sat p = do
  (s :: String) <- get
  x <- item
  if p x then return x else (put s >> die)
  \end{lstlisting}
  \label{listing:extEffSat}
  \end{figure} 

  Расширяемые эффекты, в отличие от трансформеров монад, позволяют определять 
  порядок на множестве эффектов при запуске вычисления, что позволяет, для 
  одного и того же вычисления, получить немного разное поведение, в зависимости от
  порядка обработки эффектов этого вычисления. В листинге\ref{listing:extEffparse}
  приведены две функции для запуска синтаксического анализа. 

  \begin{figure}[h]
  \begin{lstlisting}
parse p inp = run . runState inp . runFail $ p

parse' p inp = run . runFail . runState inp $ p 
  \end{lstlisting}
  \caption{Функция для запуска вычисления}
  \label{listing:extEffparse}
  \end{figure}

