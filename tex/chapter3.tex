
\chapter{Реализация парсера языка Markdown}

Язык \lstinline{Markdown} --- легковесный язык разметки, применяется для быстрой
вёрстки небольших документов. Полезен в случаях, когда нет необходимости привлекать
такие тяжеловесные форматы как \lstinline{HTML} и \LaTeX. Популярен в
интернете, к примеру, на известном хостинге программного кода
\lstinline{GitHub}.

\section{Синтаксис Markdown}

  В отличие от \lstinline{HTML} или \lstinline{XML}, \lstinline{Markdown} не имеет
  стандарта. Существует неформальное, но подробное описание базового
  синтаксиса~\cite{markdownSyntax}, а также нескольких расширенных версий, в
  числе которых так называемый \lstinline{GitHub Flavored Markdown}.

  В реализуемом парсере рассматривается подмножество базового синтаксиса,
  включающее в себя заголовки, параграфы, неупорядоченные списки и блочные цитаты.
  Дополнительной возможностью являются вставки математических формул в формате
  \LaTeX.

\section{Реализация парсера}

  Язык программирования \lstinline{Haskell} известен своей развитой системой
  типов. Аппарат алгебраических типов данных предоставляет удобные средства для
  представления абстрактного синтаксического дерева. Любой
  \lstinline{Markdown}-документ представляет собой список блоков. Блок
  представляется типом-суммой, конструкторы которого отражают рассматриваемое
  подмножество \lstinline{Markdown}. В листинге~\ref{listing:MarkdownADT}
  представлены типы, описывающие рассматриваемую грамматику.

  \begin{figure}[t]
  \begin{lstlisting}
  type Document = [Block]

  data Block = Blank
             | Header (Int,Line)
             | Paragraph [Line]
             | UnorderedList [Line]
             | BlockQuote [Line]
    deriving (Show,Eq)

  data Line = Empty | NonEmpty [Inline]
    deriving (Show,Eq)

  data Inline = Plain String
              | Bold String
              | Italic String
              | Monospace String
    deriving (Show,Eq)
  \end{lstlisting}
  \caption{Типы для представления абстрактного синтаксического дерева
  рассматриваемого подмножества \lstinline{Markdown}}
  \label{listing:MarkdownADT}
  \end{figure}

  Блоком является либо пустой блок, либо заголовок, либо параграф, либо
  неупорядоченный список, либо блочная цитата. Большинство блоков имеют в своём
  составе список строк. Строка распадается на строчные элементы, дифференцируемые
  по стилю начертания: простые, полужирные, курсивом и моноширинные.
  В листинге~\ref{listing:MarkdownInline} представлены парсеры для распознавания
  строк, парсеры \lstinline{bold}, \lstinline{italic} и \lstinline{plain}
  аналогичны парсеру \lstinline{monospace}, поэтому опущены для краткости.

  При реализации парсеров активно применяются комбинаторы из библиотек, принцип
  построения которых был описан в главе 3. Стоит подробнее остановится
  на трёх из них, их типовые аннотации приведены в
  листинге~\ref{listing:ParserCombinators}:

  \begin{figure}[h]
  \begin{lstlisting}
  many :: Parser t a -> Parser t [a]

  sepby :: Parser t a -> Parser t b -> Parser t [a]

  bracket :: Parser t a -> Parser t b -> Parser t c -> Parser t b
  \end{lstlisting}
  \caption{Типовые аннотации основных комбинаторов парсеров}
  \label{listing:ParserCombinators}
  \end{figure}

  \begin{enumerate}
    \item Комбинатор \lstinline{many} распознаёт список токенов, удовлетворяющих
    его парсеру-параметру.
    \item Комбинатор \lstinline{sepby} распознаёт последовательность токенов,
    удовлетворяющих его первому параметру и разделённых токенами, удовлетворяющими
    его второму параметру.
    \item Комбинатор \lstinline{bracket} распознаёт токены, удовлетворяющие его
    третьему параметру и заключенные между токенами, удовлетворяющими первому и
    третьему параметру соответственно.
  \end{enumerate}

  \begin{figure}[t]
  \begin{lstlisting}
  line :: TM.TextualMonoid t => Parser t Line
  line = emptyLine `mplus` nonEmptyLine

  emptyLine :: TM.TextualMonoid t => Parser t Line
  emptyLine = many (sat wspaceOrTab) >> char '\n' >> return Empty

  nonEmptyLine :: TM.TextualMonoid t => Parser t Line
  nonEmptyLine = do
    many (sat wspaceOrTab)
    l <- sepby1 (bold <|> italic <|>
                 plain <|> monospace) (many (char ' '))
    many (sat wspaceOrTab)
    char '\n'
    return . NonEmpty $ l

  monospace :: TM.TextualMonoid t => Parser t Inline
  monospace = do
    txt <- bracket (char '`') sentence (char '`')
    p   <- many punctuation
    return . Monospace $ txt ++ p
  \end{lstlisting}
  \caption{Распознавание строк из строчных элементов.}
  \label{listing:MarkdownInline}
  \end{figure}

  Получив возможность распознавать строки и строчные элементы, можно приступить к реализации парсеров для блоков. В листинге~\ref{listing:MarkdownHeader} представлен парсер для заголовка, а в листинге~\ref{listing:markdownUlist} --- для неупорядоченного списка, парсеры для остальных блоков описываются схожим образом. Здесь следует сделать замечание, что текущая версия парсера не поддерживает вложенные списки, оформляемые в \lstinline{Markdown} с помощью отступов.

  \begin{figure}[t]
  \begin{lstlisting}
  header :: TM.TextualMonoid t => Parser t Block
  header = do
    hashes <- token (some (char '#'))
    text <- nonEmptyLine
    return $ Header (length hashes,text)
  \end{lstlisting}
  \caption{Парсер для заголовка}
  \label{listing:MarkdownHeader}
  \end{figure}

  \begin{figure}[t]
  \begin{lstlisting}
  unorderedList :: TM.TextualMonoid t => Parser t Block
  unorderedList = do
    items <- some (token bullet >> line)
    return . UnorderedList $ items
    where
      bullet :: TM.TextualMonoid t => Parser t Char
      bullet = char '*' <|> char '+' <|> char '-' >>= return
  \end{lstlisting}
  \caption{Парсер для неупорядоченного списка}
  \label{listing:markdownUlist}
  \end{figure}

  \lstinline{Markdown} применяется также для электронного конспектирования и
  оформления заданий. Полезным расширением грамматики \lstinline{Markdown}
  являются вставки математических формул в формате \LaTeX. Требуется распознать
  \LaTeX-блок и оставить его без изменений, чтобы при последующей генерации кода
  по абстрактному синтаксическому дереву можно было отобразить его соответствующим
  образом. Для этого служит парсер из листинга~\ref{listing:MarkdownLaTeX}.

  \begin{figure}[h]
  \begin{lstlisting}
  blockMath :: TM.TextualMonoid t => Parser t Block
  blockMath =
    (bracket (string "$$") (some (sat (/= '$'))) (string "$$")) >>=
    return . Paragraph . (: []) . NonEmpty . (: []) . Plain .
      (\x -> "$$" ++ x ++ "$$")
  \end{lstlisting}
  \caption{Парсер \LaTeX-блоков}
  \label{listing:MarkdownLaTeX}
  \end{figure}

  В листинге \ref{listing:MarkdownDoc} представлен парсер самого верхнего уровня,
  служащий для распознавания \lstinline{Markdown}-документа как списка блоков.

  \begin{figure}[h]
  \begin{lstlisting}
  doc :: TM.TextualMonoid t => Parser t Document
  doc = many block
    where block = blank <|> header <|> paragraph <|>
                  unorderdList <|> blockquote <|> blockMath
  \end{lstlisting}
  \caption{Парсер, распознающий \lstinline{Markdown}-документ}
  \label{listing:MarkdownDoc}
  \end{figure}

\section{Генерация HTML-кода}

  Имея абстрактное синтаксическое дерево \lstinline{Markdown}-документа можно
  сгенерировать по нему исходный текст на любом требуемом языке разметки.
  В качестве целевого был выбран язык разметри гипертекста \lstinline{HTML}, для рендеринга
  \LaTeX-вставок используется \lstinline{JavaScript}-библиотека
  \lstinline{MathJax}~\cite{mathJax}. Возможно построения генераторов и для
  других языков разметки.

  Генерация кода происходит от общего к частному. Функция \lstinline{serialize}
  генерирует код по списку блоков и конкатенирует результат. Генерация каждого
  блока производится функцией \lstinline{genBlock}, которая соответствующим
  образом обрабатывает все поддерживаемые виды блоков и генерирует нужный код.
  Строки и строчные элементы генерируются функциями \lstinline{genLine} и
  \lstinline{genInline} соответственно.

  В листинге~\ref{listing:HTMLGen} представлен сокращённый кодогенератор, опущена,
  для краткости, обработка некоторых блоков и строчных элементов, которая
  происходит аналогично представленным. Этот код служит демонстрацией
  выразительности, которая предоставляется сопоставлением с образцом и
  алгебраическими типами данных.

  \begin{figure}[h]
  \begin{lstlisting}
  serialize :: Document -> String
  serialize = concatMap genBlock

  genBlock :: Block -> String
  genBlock Blank = "\n"
  genBlock (Header h) =
    "<h" ++ s ++ ">" ++ genLine (snd h) ++ "</h" ++ s ++ ">" ++ "\n"
      where s = show (fst h)
  genBlock (UnorderedList l) =
    "<ul>" ++ concatMap ((++ "\n") . genOrderedListItem) l ++ "</ul>" ++ "\n"

  genLine :: Line -> String
  genLine Empty         = ""
  genLine (NonEmpty []) = genLine Empty ++ "\n"
  genLine (NonEmpty l)  = concatMap ((++ " ") . genInline) l

  genOrderedListItem :: Line -> String
  genOrderedListItem l = "<li>" ++ genLine l ++ "</li>"

  genInline :: Inline -> String
  genInline (Plain s) = s
  genInline (Monospace s) = "<code>" ++ s ++ "</code>"
  \end{lstlisting}
  \caption{Генерация \lstinline{HTML}}
  \label{listing:HTMLGen}
  \end{figure}

  Полный исходный код парсера \lstinline{Markdown}, кодогенератора, а также вспомогательной библиотеки комбинаторов парсеров доступен в репозитории~\cite{mdParse}.
