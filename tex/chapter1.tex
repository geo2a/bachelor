\chapter{Обзор подходов к управлению вычислительными эффектами и построению
монадических парсеров}

\section{Вычисления с побочными эффектами}

  Возможность статического контроля побочных эффектов является одним из принципиальных 
  преимуществ статически типизированных языков программирования с богатыми системами типов. 
  Отделение ``чистых'' функций от вычислений, обременённых взаимодействием с 
  устройствами ввода-вывода и другими побочными эффектами, позволяет с большей
  уверенностью рассуждать о надёжности разрабатываемой программы. 

  Далее будет произведён обзор и сравнение двух подходов к управлению вычислительными 
  эффектами.   

\section{Сравнение трансформеров монад и расширяемых эффектов}
 
  В данной работе главными параметрами, относительно которых производилось сравнение, 
  выступали абстрактность и гибкость, то есть: насколько общим является тот или иной подход к управлению вычислительными эффектами, а также насколько удобно его можно подогнать к 
  специфической задаче, в данном случае, задаче синтаксического анализа.  

  \subsection{Трансформеры монад}

    В статье~\cite{monadTransformers} описаны объекты, трансформеры монад,
    которые можно использовать в качестве блоков для построения типов, описывающих
    вычисления с побочными эффектами. Каждый из трансформеров монад позволяет
    добавить некоторый вычислительный эффект к внутренней монаде, при
    этом для результирующего типа также возможно построение экземпляра класса
    типов \lstinline{Monad}.

    На данный момент трансформеры монад являются распространённым способом
    построения вычислений с несколькими побочными эффектами. Однако эта
    техника имеет недостатки: проблема невозможности автоматического
    \emph{подъёма} (англ. \lstinline{lift}) при наличии в стеке двух эффектов одного
    рода, связанная с первой проблема статически определённого порядка эффектов в
    стеке, а также невозможность скомбинировать две произвольные монады.

    В листинге~\ref{listing:mtlReadersLift} приведён пример монадической функции,
    которая должна иметь два различных конфигурационных параметра. Если не
    произвести явный подъём, то компиляция этой функции завершится с ошибкой
    проверки типов вида~\ref{listing:mtlCompileError}: компилятор не в состоянии
    самостоятельно вывести нужный тип для функции \lstinline{ask}.

    \begin{figure}[t]
    \begin{lstlisting}
    adder :: ReaderT String (Reader Int) Int
    adder = do
      str <- ask
      num <- lift ask
      return $ num + read str

    runnerForAdder = runReader (runReaderT adder "2") 3
    \end{lstlisting}
    \caption{Необходимость явного подъёма во внутреннюю монаду}
    \label{listing:mtlReadersLift}
    \end{figure}

    Порядок монад в стеке определён статически и закодирован в типе функции,
    в листинге~\ref{listing:mtlDifferentReadersLift} представлена та же функция,
    эквивалентная по смыслу, но имеющая другой тип. Значительной деталью также
    является тот факт, что в реализации этой функции \lstinline{lift} применяется
    к другому вызову функции \lstinline{ask}.

    \begin{figure}[t]
    \begin{lstlisting}
    adder :: ReaderT Int (Reader String) Int
    adder = do
      str <- lift ask
      num <- ask
      return $ num + read str

    runnerForAdder = runReader (runReaderT adder 3) "2"
    \end{lstlisting}
    \caption{Функция из листинга~\ref{listing:mtlReadersLift} с другим порядком монад в стеке}
    \label{listing:mtlDifferentReadersLift}
    \end{figure}

    Функция \lstinline{runnerForAdder} из листингов~\ref{listing:mtlReadersLift}
    и~\ref{listing:mtlDifferentReadersLift}, запускающая вычисление, полностью
    определяется типом вычисления, она производит развёртку стека монад.
    В следующем подразделе будет рассмотрено средство комбинирования вычислительных
    эффектов, при использовании которого порядок на наборе эффектов устанавливается
    именно функцией, запускающей вычисление, а сам набор является неупорядоченным.

    \begin{figure}[t]
    \begin{lstlisting}
    No instance for (MonadReader Int (ReaderT String (Reader Int)))
          arising from a use of ask
    \end{lstlisting}
    \caption{Ошибка типов при отсутствии явного подъёма}
    \label{listing:mtlCompileError}
    \end{figure}

    Следует сделать замечание относительно предыдущего примера: разнородная
    конфигурационная информация могла быть объединена в алгебраический тип данных,
    и тогда нужда в использовании двух эффектов \lstinline{Reader} отпала бы,
    однако такое решение может не сработать для других эффектов, поэтому необходимо
    искать универсальный способ.

    Ещё одной проблемой трансформеров монад является необходимость описывать 
    \lstinline{n} экземпляров классов типов, 
    по количеству уже существующих трансформеров, при введении нового трансформера.  
    Предположим, что возникла необходимость ввести класс типов для некоторого нового 
    вычислительного эффекта: листинг~\ref{listing:mtlNewEffect}. 

    \begin{figure}[t]
    \begin{lstlisting}
    class Monad m => MonadNew a m where
      action1 :: m a
      action2 :: m ()
    \end{lstlisting}
    \caption{Класс типов для описания возможностей нового вычислительного эффекта}
    \label{listing:mtlNewEffect}
    \end{figure}

    Для того, чтобы полноценно использовать новый эффект, необходимо задать 
    правила ``поднятия'' (\lstinline{lift}), то есть, описать экземпляры классов типов для 
    всех трансформеров из~\lstinline{mtl}. В листинге~\ref{listing:mtlNewEffectInstances}
    приведены примеры экземпляров классов типов.

    \begin{figure}[t]
    \begin{lstlisting}
    instance MonadNew a m => MonadNew a (IdentityT m) where
      action1 = lift action1
      action2 = lift action2

    instance MonadNew a m => MonadNew a (MaybeT m) where
      action1 = lift action1
      action2 = lift action2

    ...

    \end{lstlisting}
    \caption{Экземпляры классов типов для всех возможных комбинаций нового эффекта 
    с существующими}
    \label{listing:mtlNewEffectInstances}
    \end{figure}

    Ведутся активные поиски способов комбинирования монад, которые были бы лишены
    вышеперечисленных недостатков. Одним из развивающихся направлений являются
    расширяемые эффекты (\lstinline{Extensible Effects}), которе будут обсуждаться
    в следующем разделе.

  \subsection{Расширяемые эффекты}

    Расширяемые эффекты, подробно описанные в статье~\cite{extEffects}, представляют
    собой альтернативный трансформерам монад подход к описанию вычислений с поблочными
    эффектами.

    Суть подхода заключается в аналогии между вычислительными эффектами и
    клиент-серверным взаимодействием. Код, который собирается породить некоторый
    побочный эффект: совершить ввод-вывод, бросить исключение и тому подобное должен
    отправить \emph{запрос} на обработку этого эффекта особой глобальной сущности
    --- менеджеру эффектов. Запрос описывает действие, которое необходимо
    произвести, а также функцию-продолжение (англ. \emph{continuation}) для
    возобновления работы после обработки запроса.

    В ранних разработках, относящихся к такому подходу, менеджер запросов не был
    частью программы пользователя, а являлся отдельной сущностью, подобно ядру
    операционной системы, или обработчику \lstinline{IO}-действий в
    \lstinline{Haskell}. Этот глобальный внешний авторитет имел контроль над всеми
    ресурсами (файлами, памятью и другими): он обрабатывал запрос и принимал решение:
    исполнить его и продолжить выполнение запросившего кода, либо остановить
    вычисление и вернуть результат. При таком подходе нет никакой необходимости в
    указании явного порядка при комбинировании эффектов, однако недостатком является
    негибкость внешнего интерпретатора эффектов, кроме того, эффекты никак
    не отражаются в типах.

    Разработчики библиотеки~\lstinline{Extensible Effects} модифицировали концепцию:

    \begin{itemize}
      \item
    Глобальный обработчик запросов был заменён на средство, которое является частью
    пользовательской программы, некий аналог обработчиков исключений: теперь вместо
    единого менеджера для всех эффектов существуют локальные обработчики для каждого
    типа эффектов, такой подход называется \emph{алгебраическими
    обработчиками}~\cite{effAndHandl}. Каждый такой обработчик является менеджером
    для соответствующей клиентской части программы, а также и клиентом сам по себе:
    он пересылает запросы, которые не может обработать, менеджеру верхнего уровня.
      \item
    Разработана выразительная система типов-эффектов, которая отслеживает какие
    эффекты активны в данном вычислении. Эта система поддерживает особую структуру
    данных: \emph{открытое объединение} (\lstinline{Open Union}, индексированное
    типами копроизведение функторов), содержащее неупорядоченный набор
    вычислительных эффектов. Действие каждого обработчика отражается в типе:
    происходит удаление из набора эффекта, который был обработан. Таким
    образом система типов может отследить, все ли эффекты обработаны.
      \item
    Синтаксис для работы с эффектами построен по аналогии с синтаксисом для
    трансфомеров монад. Код, написанный с использованием трансформеров монад,
    может быть переведён на расширяемые эффекты с минимальными синтаксическими
    изменениями.
    \end{itemize}

    Есть два способа обозначить принадлежность эффекта \lstinline{m} открытому
    объединению \lstinline{r}. С помощью типового ограничения
    \mbox{\lstinline{Member m r},} которое означает, что вычисления имеет
    \emph{по крайней мере} один побочный эффект \lstinline{m}. Иначе, можно явно
    указать шаблон \lstinline{m :> r'} разложения набора \lstinline{r} на
    эффект \lstinline{m} и оставшийся набор \lstinline{r'}, что аналогично
    теоретико-множественному обозначению $\{$\lstinline{m}$\}$ $\cup$
    \lstinline{r'}. Тип \lstinline{Void} играет роль $\varnothing$, то есть
    вычисление с типом \lstinline{Eff Void a} является чистым, а вычисления с
    типом \lstinline{Eff (Reader Int :> Reader Bool :> Void)} может иметь побочный
    эффект обращения к двум средам конфигурационной информации.

    Авторы также указывают, что ограничение
    \mbox{\lstinline{Member (Reader Int) r}} выглядит похоже на ограничение
    принадлежности классу типов \lstinline{MonadReader}, более того, возможно
    объявить экземпляр этого класса для монады \lstinline{Eff r}. Однако в этом нет
    необходимости, так как тип \lstinline{Eff r} является более выразительным:
    в листинге~\ref{listing:extEff2Readers} приводится пример работы с функцией,
    имеющей два эффекта \lstinline{Reader}. Эта функция демонстрирует одно из
    преимуществ расширяемых эффектов перед трансформерами монад: пропадает
    необходимость явного вызова функции \lstinline{lift}, которую можно наблюдать
    в листингах~\ref{listing:mtlReadersLift}
    и~\ref{listing:mtlDifferentReadersLift}. Каждое вхождение функции
    \lstinline{ask} обращается к своей собственной среде, определяемой типом.

    \begin{figure}[t]
    \begin{lstlisting}
    adder :: ( Member (Reader Int) r
             , Member (Reader String) r
             ) => Eff r Int
    adder = do
      num <- ask
      str <- ask
      return $ num + read str

    runAdder = run $ runReader (runReader adder "2") (1 :: Int)
    \end{lstlisting}
    \caption{Пример функции с двумя средами конфигурации.}
    \label{listing:extEff2Readers}
    \end{figure}

    Другое важное отличие расширяемых эффектов от трансформеров монад ---
    неупорядоченность набора эффектов до запуска вычисления --- никак не проявило
    себя в примере из листинга~\ref{listing:extEff2Readers}, потому что были
    использованы одинаковые эффекты. В листинге~\ref{listing:extEffOrdering}
    рассмотрен синтетический (для краткости) пример, демонстрирующий динамическую
    установку порядка на множестве эффектов. Функция из примера считает до нуля и
    завершается с исключением. Если запускать вычисление в порядке, представленном
    в \lstinline{runCountdown1}, то результатом будет \lstinline{Nothing},
    сообщающий об исключении. При запуске в порядке \lstinline{runCountdown2},
    результатом будет пара \lstinline{(0,Nothing)} из последнего состояния и
    сообщения об исключении.

    \begin{figure}[t]
    \begin{lstlisting}
    countdown :: ( Member Fail r
                 , Member (State Int) r
                 ) => Eff r ()
    countdown = do
      state <- get
      if state == (0 :: Int)
      then die
      else put (state - 1) >> countdown

    runCountdown1 n = run $ runFail $ runState (n :: Int) $ countdown

    runCountdown2 n = run $ runState (n :: Int) $ runFail $ countdown
    \end{lstlisting}
    \caption{Порядок на множестве эффектов определяется динамически}
    \label{listing:extEffOrdering}
    \end{figure}

  \subsection{Резюме}

    Оба описанных выше подхода имеют свои достоинства и недостатки. Так, концептуально, 
    расширяемые эффекты являются более прогрессивным и гибким методом контроля 
    вычислений с побочными эффектами, главным образом за счёт возможности использовать   
    несколько однородных эффектов без потери автоматического поднятия на нужный уровень, 
    а также отсутствии необходимости в явном описании огромного количества тривиальных
    экземпляров классов типов для обеспечения механизма ``поднятия''.  
    Однако, расширяемые эффекты ещё не успели получить такого широкого распространения, 
    как трансформеры монад, в следствии чего их нельзя считать готовыми к использованию 
    в критических приложениях. 

    Трансформеры монад же, в свою очередь, являются зрелой концепцией, имеющей несколько
    реализаций в виде Haskell-модулей, и использующейся в огромном количестве кода. 

\section{Монадические функциональные парсеры}

  Популярной библиотекой монадических парсеров является библиотека
  \lstinline{Parsec}~\cite{parsec}. Это библиотека промышленного уровня,
  используемая во многих проектах, например в универсальном конвертере документов
  \lstinline{Pandoc}~\cite{pandoc}. Преимуществами \lstinline{Parsec} являются
   его гибкость и подробность сообщений об ошибках.

  Другой популярной библиотекой является
  \lstinline{attoparsec}~\cite{attoparsec}. При разработке
  \lstinline{attoparsec} акцент был сделан на скорость, поэтому было принято
  решение ограничиться только одним типом \lstinline{ByteString} и пожертвовать
  информативностью сообщений об ошибках. Основным предназначением
  \lstinline{attoparsec} является анализ сетевых протоколов.

  Недостатками обеих библиотек является недостаточная абстрактность в плане типов
  данных для представления входного потока. Применение классов типов,
  представленных в предыдущем подразделе, позволит получить абстрактный код
  способный работать с любыми строковыми типами.

  Архитектура обеих библиотек использует концепцию трансформеров монад для
  представления вычислений с несколькими побочными эффектами. Необходимо
  исследовать другие концепции многоэффектных вычислений в приложении к
  монадическим парсерам.

\section{Выбранные методы}

Для реализации поставленных практических задач использовалась концепция 
трансформеров монад~\cite{monadTransformers} и основанная на ней библиотека
\lstinline{MTL}~\cite{mtlHackage}, расширяемые эффекты~\cite{extEffects} 
и библиотека \lstinline{extensible-effects}~\cite{extensibleEffectsHackage} а также библиотека
\lstinline{monoid-subclasses}~\cite{monoidSubclassesHackage}.