
\chapter{Теоретические основы функционального программирования и элементы теории 
         категорий}

Функциональное программирование --- парадигма программирования, которая трактует 
программу как вычисление значения некоторой математической функции.

Корни функционального программирования уходят в $\lambda$"/исчисление,
формальную систему, разработанную в 1930-х годах для решения
Entscheidungsproblem~\cite{entscheidungsproblem}.

Одним из главных преимуществ функциональных языков программирования считается
высокий уровень абстракции, выразительность и высокий коэффициент повторного
использования кода. Для достижения этих свойств в языках реализуются такие
средства как параметрический полиморфизм, функции высших порядков, каррирование,
алгебраические типы данных, классы типов и другие. Использование неизменяемых
данных позволяет существенно упростить отладку программ.

\section{Классы типов}

  Классы типов позволяют накладывать ограничения на типы, определяя некоторый
  набор операций, которые могут производиться над типами, принадлежащими к
  некоторому классу. Иными словами, класс типов определяет интерфейс,
  через который можно взаимодействовать с типом.

  Рассмотрим определение стандартного класса типов языка \lstinline{Haskell},
  отвечающего за возможность сравнения на равенство:

  \begin{figure}[h]
  \begin{lstlisting}
  class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
  \end{lstlisting}
  \caption{Класс типов, для которых введено отношение эквиваленции}
  \label{listing:Eq}
  \end{figure}

  Чтобы воспользоваться возможностями класса типов для какого-то конкретного типа
  необходимо объявить этот тип экземпляром класса типов, во многих случаях это
  может быть сделано неявно, благодаря автоматическому порождению экземпляров
  компилятором \lstinline{GHC}.

  Возможность автоматического порождения экземпляра нужного класса типов для
  алгебраического типа данных:
  \begin{figure}[h]
  \begin{lstlisting}
  data Numbers = One | Two | Three deriving Eq

  ghci> One /= Two
  True
  \end{lstlisting}
  \caption{Автоматическое порождение экземпляров классов типов}
  \label{listing:List}
  \end{figure}


  В некоторых случаях необходимо описать экземпляр явно, такая возможность тоже
  существует.

  \begin{figure}[h]
  \begin{lstlisting}
  data Foo = Foo {x :: Integer, str :: String}

  instance Eq Foo where
    (Foo x1 str1) == (Foo x2 str2) = (x1 == x2) &&
                                     (str1 == str2)
  \end{lstlisting}
  \caption{Явное описание экземпляра класса типов}
  \label{listing:Instance}
  \end{figure}

  Как уже говорилось ранее, код, написанный на языке программирования
  \lstinline{Haskell} имеет очень высокий уровень абстракции. Далее будут
  рассмотрены два классы типов, представляющие структуры, введённые в язык
  \lstinline{Haskell} под влиянием исследований в области связи теоретической
  информатики и теории категорий. Эти структуры представляют абстракцию для
  вычислений с побочными эффектами. В дальнейшем изложении эти классы типов будут
  использоваться для построения парсеров.

\section{Функтор}

  Рассмотрим определение класса типов \lstinline{Functor} из стандартной
  библиотеки \lstinline{Haskell}:

  \begin{figure}[h]
  \begin{lstlisting}
    class Functor f where
      fmap :: (a -> b) -> f a -> f b
  \end{lstlisting}
  \caption{Класс типов \lstinline{Functor}}
  \label{listing:Functor}
  \end{figure}

  Как видно из определения, каждый тип, являющийся функтором, должен предоставлять
  функцию \lstinline{fmap}.

  Сформировались два основных неформальных описания функтора: контейнер,
  содержащий в себе значения определённого типа и вычисление, которое производится
  в некотором контексте. Согласно первой из этих трактовок, функция
  \lstinline{fmap} применяет подаваемую ей на вход функцию к значениям в
  контейнере и возвращает изменённые значения, с сохранением структуры контейнера.
  Если же говорить в терминах вычислительных контекстов, то \lstinline{fmap}
  модифицирует вычисление в контексте, но сам контекст остаётся неизменным.

  Упомянутые выше списки языка \lstinline{Haskell} являются функторами, для них в
  качестве \lstinline{fmap} можно выбрать функцию \lstinline{map}.

  Важно заметить, что не любой тип, для которого определена функция
  \lstinline{fmap} является функтором, необходимо также потребовать выполнения
  двух уравнений, называемых законами функтора:

  \begin{figure}[h]
  \begin{lstlisting}
  fmap id = id
  fmap (g . h) = (fmap g) . (fmap h)
  \end{lstlisting}
  \caption{Законы функтора}
  \label{listing:FunctorLaws}
  \end{figure}

  Здесь \lstinline{id} --- тождественная функция, а \lstinline{.} --- инфиксный
  оператор композиции функций. Эти уравнения отражают теоретико-категорное
  определение функтора как отображения между категориями, сохраняющее единичный
  морфизм и композицию. В случае \lstinline{Haskell} рассматриваются эндофункторы
  над категорией \lstinline{Hask} --- категорией типов языка \lstinline{Haskell}.

\section{Аппликативный функтор}

  Аппликативный функтор является специализацией функтора, допускающей применение
  функции, находящейся внутри некоторого контекста, к значению в таком же
  контексте. Аппликативные функторы также иногда называют \emph{идиомами}
  (англ. idioms).

  В языке \lstinline{Haskell} для представления аппликативных функторов
  используется стандартный класс типов \lstinline{Applicative},
  описанный в модуле \lstinline{Control.Applicative}.

  \begin{figure}[h]
  \begin{lstlisting}
  class (Functor f) => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}
  \caption{Класс типов \lstinline{Applicative}}
  \label{listing:Applicative}
  \end{figure}

  Для всякого типа, который является аппликативным функтором, должны выполняться
  законы, представленные в листинге~\ref{listing:ApplicativeLaws}.

  \begin{figure}[h]
  \begin{lstlisting}
  pure id <*> v = v

  pure (.) <*> u <*> v <*> w = u <*> (v <*> w)

  pure f <*> pure x = pure (f x)

  u <*> pure y = pure ($ y) <*> u
  \end{lstlisting}
  \caption{Законы аппликативного функтора}
  \label{listing:ApplicativeLaws}
  \end{figure}

  Любая монада является аппликативным функтором, но не каждый аппликативный
  функтор является монадой. То есть, интерфейсу класса типов
  \lstinline{Applicative} удовлетворяет больше типов, чем интерфейсу класса типов
  \lstinline{Monad}.

  С понятием аппликативного функтора связан особый синтаксис описания вычислений с
  эффектами на \lstinline{Haskell}, называемый \emph{аппликативным стилем}. Этот
  стиль имеет преимущество относительно \lstinline{do}-нотации для монад ---
  компилятор имеет возможность генерировать для него более оптимальный код.
  Многие монадические функции могут быть переписаны в аппликативном стиле.
  В листинге~\ref{listing:MonadApplicative} представлена короткая монадическая
  функция и эквивалентная ей аппликативная, задача которых прочитать из потока
  стандартного ввода две строки выполнить их конкатенацию и вернуть результат.

  \begin{figure}
  \begin{lstlisting}
  action :: IO String
  action = do
    a <- getLine
    b <- getLine
    return $ a ++ b

  action :: IO String
  action = (++) <$> getLine <*> getLine
  \end{lstlisting}
  \caption{\lstinline{do}-нотация и аппликативный стиль}
  \label{listing:MonadApplicative}
  \end{figure}

\section{Монада}

  Вершиной иерархии типов, описывающих вычисления с побочными эффектами,
  являются монады. Возникнув как средство для введения в чистый функциональный
  язык возможности выполнять операции ввода-вывода, монады были обобщены и на
  другие вычислительные эффекты, для которых есть необходимость в построении
  композиции функций, и теперь являются наиболее известной абстракцией такого
  сорта.

  Для представления монад в языке \lstinline{Haskell} используется класс типов
  \lstinline{Monad}. Кроме того, существует три закона монады, которые должны
  выполняться для каждого типа, имеющего экземпляр класса типов \lstinline{Monad}.
  Эти законы отражают тот факт, что монада является моноидом в категории
  эндофункторов. Важно знать, что система типов не гарантирует выполнения
  монадических законов, ответственность за них целиком лежит на программисте,
  который разрабатывает экземпляр \lstinline{Monad} для некоторого типа.

  \begin{figure}[h]
  \begin{lstlisting}
  class Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    (>>) :: m a -> m b -> m b
    return :: a -> m a
  \end{lstlisting}
  \caption{Класс типов \lstinline{Monad}}
  \label{listing:Monad}
  \end{figure}

  \begin{figure}[h]
  \begin{lstlisting}
  return a >>= k = k a
  m >>= return = m
  m >>= (\x -> k x >>= h) = (m >>= k) >>= h
  \end{lstlisting}
  \caption{Законы монады}
  \label{listing:MonadLaws}
  \end{figure}

  Монада естественным образом возникает при построении функциональных парсеров,
  которые описываются в третьей главе.

\section{Копроизведение}

  Копроизведением объектов $A$ и $B$ в категории называется объект $A + B$ и две
  стрелки $i_1 : A \to A + B$ и $i_2 : B \to A + B$ такие, что для всех стрелок
  $f : A \to C$ и $g : B \to C$ существует единственная стрелка
  $\langle f|g\rangle  : A + B \to C$ для которой следующая диаграмма
  коммутативна~\cite{TeorCat}.

  \begin{center}
  \begin{tikzcd}
  A \arrow{r}{f} \arrow{rd}[swap]{i_1}
  &C
  &B \arrow{ld}{i_2} \arrow{l}[swap]{g}\\
  &A+B \arrow{u}[description]{\langle f|g\rangle}
  \end{tikzcd}
  \end{center}

  Стрелки $i_1$ и $i_2$ называются каноническими вложениями.

  В случае категории множеств копроизведением является дизъюнктивное
  или размеченное объединение.

  Понятие копроизведения, в случае категории типов языка \lstinline{Haskell},
  потребуется в главе 2, для описания расширяемых эффектов.

\section{Моноиды в функциональном программировании}

  Моноидом является множество $M$ с заданной на нём бинарной ассоциативной
  операцией $*$, и в котором существует такой элемент
  $e$, что $\forall x \in M~e*x = x*e = x$. Элемент $e$ называется единицей.

  В языке \lstinline{Haskell} для представления моноидов существует специальный
  класс типов.

  \begin{figure}[h]
  \begin{lstlisting}
  class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
  \end{lstlisting}
  \caption{Моноид в \lstinline{Haskell}}
  \label{listing:Monoid}
  \end{figure}

  Cтроки с операцией конкатенации и пустой строкой в качестве единицы являются
  моноидом. С помощью класса типов \lstinline{Monoid} возможна абстрактная работа
  с любыми строковыми типами. Однако существуют ситуации, в которых интерфейса
  класса типов \lstinline{Monoid} оказывается недостаточно, возникает
  необходимость в функции, отделяющей префикс, аналогичной функции
  \lstinline{head} для списков. Для таких целей создана библиотека
  \lstinline{monoid-subclasses}~\cite{monoids}, предоставляющая
  классы типов, являющиеся моноидами специального вида, которые допускают
  необходимые дополнительные операции. В случае парсеров такой дополнительной
  операцией является аналог операции разделения списка на голову и хвост.

  \begin{figure}[h]
  \begin{lstlisting}
  splitCharacterPrefix :: t -> Maybe (Char, t)

  uncons :: [a] -> Maybe (a, [a])
  \end{lstlisting}
  \caption{Отделение атомарного префикса и взятие головы списка}
  \label{listing:Monoid}
  \end{figure}