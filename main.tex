% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (section) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro
В работе рассматриваются технологии функционального программирования, 
предназначенные для описания вычислений с побочными эффектами, производится 
сравнение методов построения вычислений с несколькими побочными эффектами,
и приводятся способы их использование для построения библиотек функциональных 
парсеров.

\chapter{Предварительные сведения}

\section{Использованные в работе технологии фукционального программирования}

Функциональное программирование --- парадигма программирования, которая трактует 
программу как вычисление значения некоторой математической функции.

Корни функционального программирования уходят в $\lambda$"/исчисление, 
формальную систему, разработанную в 1930-х годах для решения 
Entscheidungsproblem~\autocite{Entscheidungsproblem}.

Одним из главных преимуществ функциональных языков программирования считается 
высокий уровень абстракции, выразительность и высокий коэффициент повторного 
использования кода. Для достижения этих свойств в языках реализуются такие 
средства как параметрический полиморфизм, функции высших порядков, каррирование, 
алгебраические типы данных, классы типов и другие. Использование неизменяемых 
данных позволяет существенно упростить отладку программ.

\subsection{Функции высших порядков}
Ключевой концепцией функционального программирования являются так называемые 
функции высших порядков (англ. higher-order function). Они представляют собой 
функции, в качестве параметров которых могут выступать другие функции.

В качестве примера рассмотрим одну из функций стандартной библиотеки языка 
Haskell (листинг~\ref{listing:map}).

\begin{figure}[h]
\begin{lstlisting}
map :: (a -> b) -> [a] -> [b]

ghci> map (+3) [1,5,3,1,6]
[4,8,6,4,9]
\end{lstlisting}
\caption{Функция для трансформации списка}
\label{listing:map}
\end{figure}

Как видно из типовой аннотации, она принимает на вход функцию, преобразующую 
значение типа \lstinline{a} к значению типа \lstinline{b}, и список значений 
типа \lstinline{a}, возвращаемым значением является список результатов 
применения функции к значениям из входного списка.

Функция, рассмотренная в примере, обладает ценным свойством: она является 
полиморфной по своему параметру и выходному значению. Возможность написания 
параметрически полиморфных функций позволяет при программировании на 
\lstinline{Haskell} повысить повторное использование кода и выразительность, 
чему способствует также простота синтаксиса, применяемого для описания таких 
функций.

\subsection{Алгебраические типы данных}

Алгебраические типы данных --- минималистический, но выразительный способ 
описания типов данных, применяемый в функциональных языках программирования. 
Выделяют типы-перечисления или типы-суммы --- аналог перечислений 
\lstinline{enum} из императивных языков, и типы-контейнеры или типы-произведения
 --- аналог структур \lstinline{struct} или записей \lstinline{record}.


Рассмотрим простой тип-сумму, используемый в языке \lstinline{Haskell} для 
представления булевых констант:

\begin{figure}[h]
\begin{lstlisting}
data Bool = False | True
\end{lstlisting}
\caption{Элементарный тип-сумма}
\label{listing:Bool}
\end{figure}

Этот тип распадается на два конструктора значений (англ. value constructors), 
экземпляр значения типа \lstinline{Bool} может являться одним из возможных 
значений (\lstinline{True} или \lstinline{False}).

Теперь рассмотрим тип-произведение и пример создание константы этого типа:

\begin{figure}[h]
\begin{lstlisting}
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     }

p = Person { firstName = "John"
           , lastName  = "Lennon"
           , age = 43
           }
\end{lstlisting}
\caption{Элементарный тип-произведение}
\label{listing:Bool}
\end{figure}

Алгебраические типы данных могут быть параметризованы --- это позволяет 
создавать, например, полиморфные контейнеры.

Рассмотрим определение списка, аналогичное определению из стандартной библиотеки 
языка Haskell:

\begin{figure}[h]
\begin{lstlisting}
data List a = Nil | Cons a (List a)
\end{lstlisting}
\caption{Определение списка}
\label{listing:List}
\end{figure}

Здесь \lstinline{List} является конструктором типа (type constructor) с одним 
типовым параметром, а \lstinline{Nil} и \lstinline{Cons} --- конструкторами 
значений. Стоит также заметить, что \lstinline{List} является рекурсивным типом.

\subsection{Классы типов}

Классы типов позволяют накладывать ограничения на типы, определяя некоторый 
набор операций, которые могут производиться над типами, принадлежащими к 
некоторому классу. Иными словами, класс типов определяет интерфейс, 
через который можно взаимодействовать с типом.

Рассмотрим определение стандартного класса типов языка \lstinline{Haskell}, 
отвечающего за возможность сравнения на равенство:

\begin{figure}[h]
\begin{lstlisting}
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{lstlisting}
\caption{Класс типов, для которых введено отношение эквиваленции}
\label{listing:Eq}
\end{figure}

Чтобы воспользоваться возможностями класса типов для какого-то конкретного типа 
необходимо объявить этот тип экземпляром класса типов, во многих случаях это 
может быть сделано неявно, благодаря автоматическому порождению экземпляров 
компилятором \lstinline{GHC}.

Возможность автоматического порождения экземпляра нужного класса типов для 
алгебраического типа данных:
\begin{figure}[h]
\begin{lstlisting}
data Numbers = One | Two | Three deriving Eq

ghci> One /= Two
True
\end{lstlisting}
\caption{Автоматическое порождение экземпляров классов типов}
\label{listing:List}
\end{figure}


В некоторых случаях необходимо описать экземпляр явно, такая возможность тоже 
существует.

\begin{figure}[h]
\begin{lstlisting}
data Foo = Foo {x :: Integer, str :: String}

instance Eq Foo where
  (Foo x1 str1) == (Foo x2 str2) = (x1 == x2) &&
                                   (str1 == str2)
\end{lstlisting}
\caption{Явное описание экземпляра класса типов}
\label{listing:Instance}
\end{figure}

Как уже говорилось ранее, код, написанный на языке программирования 
\lstinline{Haskell} имеет очень высокий уровень абстракции. Далее будут 
рассмотрены два классы типов, представляющие структуры, введённые в язык 
\lstinline{Haskell} под влиянием исследований в области связи теоретической 
информатики и теории категорий. Эти структуры представляют абстракцию для 
вычислений с побочными эффектами. В дальнейшем изложении эти классы типов будут
использоваться для построения парсеров.

\subsection{Функтор}

Рассмотрим определение класса типов \lstinline{Functor} из стандартной 
библиотеки \lstinline{Haskell}:

\begin{figure}[h]
\begin{lstlisting}
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{lstlisting}
\caption{Класс типов \lstinline{Functor}}
\label{listing:Functor}
\end{figure}

Как видно из определения, каждый тип, являющийся функтором, должен предоставлять
функцию \lstinline{fmap}.

Сформировались два основных неформальных описания функтора: контейнер, 
содержащий в себе значения определённого типа и вычисление, которое производится
в некотором контексте. Согласно первой из этих трактовок, функция 
\lstinline{fmap} применяет подаваемую ей на вход функцию к значениям в 
контейнере и возвращает изменённые значения, с сохранением структуры контейнера.
Если же говорить в терминах вычислительных контекстов, то \lstinline{fmap}
модифицирует вычисление в контексте, но сам контекст остаётся неизменным.

Упомянутые выше списки языка \lstinline{Haskell} являются функторами, для них в
качестве \lstinline{fmap} можно выбрать функцию \lstinline{map}.

Важно заметить, что не любой тип, для которого определена функция 
\lstinline{fmap} является функтором, необходимо также потребовать выполнения 
двух уравнений, называемых законами функтора:

\begin{figure}[h]
\begin{lstlisting}
fmap id = id
fmap (g . h) = (fmap g) . (fmap h)
\end{lstlisting}
\caption{Законы функтора}
\label{listing:FunctorLaws}
\end{figure}

Здесь \lstinline{id} --- тождественная функция, а \lstinline{.} --- инфиксный
оператор композиции функций. Эти уравнения отражают теоретико-категорное 
определение функтора как отображения между категориями, сохраняющее единичный 
морфизм и композицию. В случае \lstinline{Haskell} рассматриваются эндофункторы 
над категорией \lstinline{Hask} --- категорией типов языка \lstinline{Haskell}.

\subsection{Аппликативный функтор}

Аппликативный функтор является специализацией функтора, допускающей применение 
функции, находящейся внутри некоторого контекста, к значению в таком же 
контексте. Аппликативные функторы также иногда называют \emph{идиомами} 
(англ. idioms).

В языке \lstinline{Haskell} для представления аппликативных функторов 
используется стандартный класс типов \lstinline{Applicative}, 
описанный в модуле \lstinline{Control.Applicative}.

\begin{figure}[h]
\begin{lstlisting}
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}
\caption{Класс типов \lstinline{Applicative}}
\label{listing:Applicative}
\end{figure}

Для всякого типа, который является аппликативным функтором, должны выполняться 
законы, представленные в листинге~\ref{listing:ApplicativeLaws}.

\begin{figure}[h]
\begin{lstlisting}
pure id <*> v = v

pure (.) <*> u <*> v <*> w = u <*> (v <*> w)

pure f <*> pure x = pure (f x)

u <*> pure y = pure ($ y) <*> u
\end{lstlisting}
\caption{Законы аппликативного функтора}
\label{listing:ApplicativeLaws}
\end{figure}

Любая монада является аппликативным функтором, но не каждый аппликативный 
функтор является монадой. То есть, интерфейсу класса типов 
\lstinline{Applicative} удовлетворяет больше типов, чем интерфейсу класса типов 
\lstinline{Monad}.

С понятие аппликативного функтора связан особый синтаксис описания вычислений с 
эффектами на \lstinline{Haskell}, называемый \emph{аппликативным стилем}. Этот 
стиль имеет преимущество относительно \lstinline{do}-нотации для монад --- 
компилятор имеет возможность генерировать для него более оптимальный код. 
Многие монадические функции могут быть переписаны в аппликативном стиле. 
В листинге~\ref{listing:MonadApplicative} представлена короткая монадическая 
функция и эквивалентная ей аппликативная, задача которых прочитать из потока 
стандартного ввода две строки выполнить их конкатенацию и вернуть результат.

\begin{figure}
\begin{lstlisting}
action :: IO String
action = do
  a <- getLine
  b <- getLine
  return $ a ++ b

action :: IO String
action = (++) <$> getLine <*> getLine
\end{lstlisting}
\caption{\lstinline{do}-нотация и аппликативный стиль}
\label{listing:MonadApplicative}
\end{figure}

\subsection{Монада}

Вершиной иерархии типов, описывающих вычисления с побочными эффектами, 
являются монады. Возникнув как средство для введения в чистый функциональный 
язык возможности выполнять операции ввода-вывода, монады были обобщены и на 
другие вычислительные эффекты, для которых есть необходимость в построении 
композиции функций, и теперь являются наиболее известной абстракцией такого 
сорта.

Для представления монад в языке \lstinline{Haskell} используется класс типов 
\lstinline{Monad}. Кроме того, существует три закона монады, которые должны 
выполняться для каждого типа, имеющего экземпляр класса типов \lstinline{Monad}.
Эти законы отражают тот факт, что монада является моноидом в категории 
эндофункторов. Важно знать, что система типов не гарантирует выполнения 
монадических законов, ответственность за них целиком лежит на программисте, 
который разрабатывает экземпляр \lstinline{Monad} для некоторого типа.

\begin{figure}[h]
\begin{lstlisting}
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
\end{lstlisting}
\caption{Класс типов \lstinline{Monad}}
\label{listing:Monad}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}
return a >>= k = k a
m >>= return = m
m >>= (\x -> k x >>= h) = (m >>= k) >>= h
\end{lstlisting}
\caption{Законы монады}
\label{listing:MonadLaws}
\end{figure}

Монада естественным образом возникает при построении функциональных парсеров, 
о которых речь пойдёт в следующих разделах.

\subsection{Моноиды в функциональном программировании}

Моноидом является множество $M$ с заданной на нём бинарной ассоциативной 
операцией $*$, и в котором существует такой элемент 
$e$, что $\forall x \in M~e*x = x*e = x$. Элемент $e$ называется единицей.

Моноиды являются одной из самых популярных алгебраических структур в 
теоретической информатике.

В языке \lstinline{Haskell} для представления моноидов существует специальный 
класс типов.

\begin{figure}[h]
\begin{lstlisting}
class Monoid a where
  mempty  :: a
  mappend :: a -> a -> a
\end{lstlisting}
\caption{Моноид в \lstinline{Haskell}}
\label{listing:Monoid}
\end{figure}

Cтроки с операцией конкатенации и пустой строкой в качестве единицы являются 
моноидом. С помощью класса типов \lstinline{Monoid} возможна абстрактная работа 
с любыми строковыми типами. Однако существуют ситуации, в которых интерфейса 
класса типов \lstinline{Monoid} оказывается недостаточно, возникает 
необходимость в функции, отделяющей префикс, аналогичной функции 
\lstinline{head} для списков. Для таких целей создана библиотека 
\lstinline{monoid-subclasses}~\autocite{MonoidSubclasses}, предоставляющая 
классы типов, являющиеся моноидами специального вида, которые допускают 
необходимые дополнительные операции. В случае парсеров такой дополнительной 
операцией является отделение атомарного префикса --- аналог операции разделения 
списка на голову и хвост.

\begin{figure}[h]
\begin{lstlisting}
splitCharacterPrefix :: t -> Maybe (Char, t)

uncons :: [a] -> Maybe (a, [a])
\end{lstlisting}
\caption{Отделение атомарного префикса и взятие головы списка}
\label{listing:Monoid}
\end{figure}

\section{Существующие библиотеки функциональных парсеров}

Наиболее популярной библиотекой монадических парсеров является библиотека 
\lstinline{Parsec}~\autocite{Parsec}. Это библиотека промышленного уровня, 
используемая во многих проектах, например в универсальном конвертере документов 
\lstinline{Pandoc}~\autocite{Pandoc}. Преимуществами \lstinline{Parsec} являются
 его гибкость и подробность сообщений об ошибках.

Другой популярной библиотекой является 
\lstinline{attoparsec}~\autocite{Attoparsec}. При разработке 
\lstinline{attoparsec} акцент был сделан на скорость, поэтому было принято 
решение ограничиться только одним типом \lstinline{ByteString} и пожертвовать 
информативностью сообщений об ошибках. Основным предназначением 
\lstinline{attoparsec} является анализ сетевых протоколов.

Недостатками обеих библиотек является недостаточная абстрактность в плане типов
данных для представления входного потока. Применение классов типов, 
представленных в предыдущем подразделе, позволит получить абстрактный код 
способный работать с любыми строковыми типами.

Архитектура обеих библиотек использует концепцию трансформеров монад для 
представления вычислений с несколькими побочными эффектами. Необходимо 
исследовать другие концепции многоэффектных вычислений в приложении к 
монадическим парсерам.

\chapter{Комбинирование Вычислительный Эффектов}

\section{Трансформеры Монад}

В статье~\autocite{MonadTransformers} описаны объекты, трансформеры монад, 
которые можно использовать в качестве блоков для построения типов, описывающих 
вычисления с побочными эффектами. Каждый из трансформеров монад позволяет 
добавить некоторый вычислительный эффект к внутренней монаде, при 
этом для результирующего типа также возможно построение экземпляра класса 
типов \lstinline{Monad}.

На данный момент трансформеры монад являются общепринятым способом построения 
монадических вычислений с несколькими побочными эффектами. Тем не менее, эта 
техника имеет признанные недостатки: проблема невозможности автоматического 
\emph{подъёма} (англ. \lstinline{lift}) при наличии в стеке двух эффектов одного
рода, связанная с первой проблема статически определённого порядка эффектов в 
стеке, а также невозможность скомбинировать две произвольные монады.

В листинге~\ref{listing:mtlReadersLift} приведён пример монадической функции, 
которая должна иметь два различных конфигурационных параметра. Если не 
произвести явный подъём, то компиляция этой функции завершится с ошибкой 
проверки типов вида~\ref{listing:mtlCompileError}: компилятор не в состоянии 
самостоятельно вывести нужный тип для функции \lstinline{ask}.

\begin{figure}[t]
\begin{lstlisting}
adder :: ReaderT String (Reader Int) Int
adder = do
  str <- ask
  num <- lift ask
  return $ num + read str

runnerForAdder = runReader (runReaderT adder "2") 3
\end{lstlisting}
\caption{Необходимость явного подъёма во внутреннюю монаду}
\label{listing:mtlReadersLift}
\end{figure}

Порядок монад в стеке определён статически и закодировал в типе функции, 
в листинге~\ref{listing:mtlDifferentReadersLift} представлена та же функция, 
эквивалентная по смыслу, но имеющая другой тип. Значительной деталью также 
является тот факт, что в реализации этой функции \lstinline{lift} применяется 
к другому вызову функции \lstinline{ask}.

\begin{figure}[t]
\begin{lstlisting}
adder :: ReaderT Int (Reader String) Int
adder = do
  str <- lift ask
  num <- ask
  return $ num + read str

runnerForAdder = runReader (runReaderT adder 3) "2"
\end{lstlisting}
\caption{Функция из листинга~\ref{listing:mtlReadersLift} с другим порядком монад в стеке}
\label{listing:mtlDifferentReadersLift}
\end{figure}

Функция \lstinline{runnerForAdder} из листингов~\ref{listing:mtlReadersLift} 
и~\ref{listing:mtlDifferentReadersLift}, запускающая вычисление, полностью 
определяется типом вычисления, она производит развёртку стека монад. 
В следующем подразделе будет рассмотрено средство комбинирования вычислительных 
эффектов, при использовании которого порядок на наборе эффектов устанавливается 
именно функцией, запускающей вычисление, а сам набор является неупорядоченным.

\begin{figure}[t]
\begin{lstlisting}
No instance for (MonadReader Int (ReaderT String (Reader Int)))
      arising from a use of ask
\end{lstlisting}
\caption{Ошибка типов при отсутствии явного подъёма}
\label{listing:mtlCompileError}
\end{figure}

Следует сделать замечание относительно предыдущего примера: разнородная 
конфигурационная информация могла быть объединена в алгебраический тип данных, 
и тогда нужда в использовании двух эффектов \lstinline{Reader} отпала бы, 
однако такое решение может не сработать для других эффектов, поэтому необходимо 
искать универсальный способ.

Ведутся активные поиски способов комбинирования монад, которые были бы лишены вышеперечисленных недостатков. Одним из развивающихся направлений являются расширяемые эффекты (\lstinline{Extensible Effects}), речь о которых пойдёт в следующем подразделе.

\section{Расширяемые эффекты}

Этот подраздел посвящён альтернативному трансформерам монад способу 
комбинирования вычислительных эффектов, 
представленному в статье~\autocite{ExtEffects}.

\subsection{Краткое описание библиотеки \lstinline{Extensible Effects}}

Суть подхода заключается в аналогии между вычислительными эффектами и 
клиент-серверным взаимодействием. Код, который собирается породить некоторый 
побочный эффект: совершить ввод-вывод, бросить исключение и т.п. должен 
отправить \emph{запрос} на обработку этого эффекта особой сущности --- менеджеру 
эффектов. Запрос описывает действие, которое необходимо произвести, а также 
функцию-продолжение (англ. \emph{continuation}) для возобновления работы после
обработки запроса.

В ранних разработках, относящихся к такому подходу, менеджер запросов не был 
частью программы пользователя, а являлся отдельной сущностью, подобно ядру 
операционной системы, или обработчику \lstinline{IO}-действий в 
\lstinline{Haskell}. Этот глобальный внешний авторитет имел контроль над всеми
ресурсами (файлами, памятью и т. п.): он обрабатывал запрос и принимал решение: 
исполнить его и продолжить выполнение запросившего кода, либо остановить 
вычисление и вернуть результат. При таком подходе нет никакой необходимости в
указании явного порядка при комбинировании эффектов, однако недостатком является
негибкость внешнего интерпретатора эффектов, кроме того, эффекты никак 
не отражаются в типах.

Разработчики библиотеки~\lstinline{Extensible Effects} модифицировали концепцию:

\begin{itemize}
  \item
Глобальный обработчик запросов был заменён на средство, которое является частью 
пользовательской программы, некий аналог обработчиков исключений: теперь вместо 
единого авторитета для всех эффектов существуют частичные авторитеты для каждого 
типа эффектов, такой подход называется \emph{алгебраическими обработчиками}. 
Каждый такой обработчик является авторитетом для соответствующей клиентской 
части программы, а также и клиентом сом по себе: он пересылает запросы, которые 
не может обработать, обработчику более верхнего уровня.
  \item
Разработана выразительная система типов-эффектов, которая отслеживает какие 
эффекты активны в данном вычислении. Эта система поддерживает особую структуру 
данных: \emph{открытое объединение} (\lstinline{Open Union}, индексированное 
типами копроизведение функторов), содержащее неупорядоченный набор 
вычислительных эффектов. Действие каждого обработчика отражается в типе удаление
из этого набора эффекта, который был обработан, таким образом система типов 
может отследить, все ли эффекты обработаны.
  \item
Синтаксис для работы с эффектами построен по аналогии с синтаксисом для 
трансфомеров монад и код, написанный с их использованием, может быть 
переведённый на расширяемые эффекты с минимальными синтаксическими изменениями.
\end{itemize}

Есть два способа обозначить принадлежность эффекта \lstinline{m} открытому 
объединению \lstinline{r}. С помощью типового ограничения 
\mbox{\lstinline{Member m r},} которое означает, что вычисления имеет 
\emph{по крайней мере} один побочный эффект \lstinline{m}. Иначе, можно явно 
указать шаблон \lstinline{m :> r'} разложения набора \lstinline{r} на 
эффект \lstinline{m} и оставшийся набор \lstinline{r'}, что аналогично 
теоретико-множественному обозначению $\{$\lstinline{m}$\}$ $\cup$ 
\lstinline{r'}. Тип \lstinline{Void} играет роль $\varnothing$, то есть 
вычисление с типом \lstinline{Eff Void a} является чистым, а вычисления с 
типом \lstinline{Eff (Reader Int :> Reader Bool :> Void)} может иметь побочный 
эффект обращения к двум средам конфигурационной информации.

Авторами также подмечается, что ограничение 
\mbox{\lstinline{Member (Reader Int) r}} выглядит похоже на ограничение 
принадлежности классу типов \lstinline{MonadReader}, более того, возможно 
объявить экземпляр этого класса для монады \lstinline{Eff r}. Однако в этом нет
необходимости, так как тип \lstinline{Eff r} является более выразительным: 
в листинге~\ref{listing:extEff2Readers} приводится пример работы с функцией, 
имеющей два эффекта \lstinline{Reader}. Эта функция демонстрирует одно из 
преимуществ расширяемых эффектов перед трансформерами монад: пропадает 
необходимость явного вызова функции \lstinline{lift}, которую можно наблюдать 
в листингах~\ref{listing:mtlReadersLift} 
и~\ref{listing:mtlDifferentReadersLift}. Каждое вхождение функции 
\lstinline{ask} обращается к своей собственной среде, определяемой типом.

\begin{figure}[t]
\begin{lstlisting}
adder :: ( Member (Reader Int) r
         , Member (Reader String) r
         ) => Eff r Int
adder = do
  num <- ask
  str <- ask
  return $ num + read str

runAdder = run $ runReader (runReader adder "2") (1 :: Int)
\end{lstlisting}
\caption{Пример функции с двумя средами конфигурации.}
\label{listing:extEff2Readers}
\end{figure}

Другое важным отличие расширяемых эффектов от трансформеров монад --- 
неупорядоченность набора эффектов до запуска вычисления --- никак не проявило 
себя в примере из листинга~\ref{listing:extEff2Readers}, потому что были 
использованы одинаковые эффекты. В листинге~\ref{listing:extEffOrdering} 
рассмотрен синтетический (для краткости) пример, демонстрирующий динамическую 
установку порядка на множестве эффектов. Функция из примера считает до нуля и 
завершается с исключением. Если запускать вычисление в порядке, представленном 
в \lstinline{runCountdown1}, то результатом будет служить \lstinline{Nothing}, 
сообщающий об исключении. При запуске в порядке \lstinline{runCountdown2}, 
результатом будет пара \lstinline{(0,Nothing)} из последнего состояния и 
сообщения об исключении.

\begin{figure}[t]
\begin{lstlisting}
countdown :: ( Member Fail r
             , Member (State Int) r
             ) => Eff r ()
countdown = do
  state <- get
  if state == (0 :: Int)
  then die
  else put (state - 1) >> countdown

runCountdown1 n = run $ runFail $ runState (n :: Int) $ countdown

runCountdown2 n = run $ runState (n :: Int) $ runFail $ countdown
\end{lstlisting}
\caption{Порядок на множестве эффектов определяется динамически}
\label{listing:extEffOrdering}
\end{figure}

\subsection{Пример практического использования}

В этом подразделе будет рассмотрены некоторые составные части системной утилиты,
написанной с использованием библиотеки \lstinline{Extensible Effects}. 
Задача этой утилиты --- отслеживание изменений содержимого некоторой директории
и выполнение заданных сценариев командной оболочки в качестве реакции на эти 
изменения. Git-репозиторий с исходным кодом на языке \lstinline{Haskell} 
доступен по адресу~\autocite{FileTrigger}.

На этапе проектирования приложения необходимо определить, какие вычислительные
эффекты будут им порождаться. Рассматриваемая утилита будет работать с файловой
системой, значит потребуется эффект \lstinline{IO}, иметь внутреннее 
состояние --- необходим эффект \lstinline{State}, а также будет иметь 
конфигурационную информацию --- потребуется эффекта \lstinline{Reader}.

\begin{figure}[t]
\begin{lstlisting}
loop :: ( Member (Reader AppConfig) r
        , Member (State AppState)   r
        , SetMember Lift (Lift IO)  r
        ) => Eff r ()
loop = do
  cfg <- ask
  currentFilesList <- lift $ getFilesInfo $ directory cfg
  handleCreate currentFilesList
  lift $ threadDelay $ refreshRate cfg
  curTime <- lift getCurrentTime
  put $ (AppState currentFilesList curTime)
  loop
\end{lstlisting}
\caption{Главный цикл приложения}
\label{listing:ftMainLoop}
\end{figure}

В листинге~\ref{listing:ftMainLoop} представлена упрощённая функция главного 
цикла программы, типовая аннотация отражает наличие в результирующем наборе 
эффектов \lstinline{r} трёх составляюших: \lstinline{Reader}, \lstinline{State} 
и \lstinline{IO}.

Как уже говорилось ранее, порядок на наборе эффектов устанавливается в момент 
запуска вычисления, для чего служит функция из листинга~\ref{listing:ftRun}.

\begin{figure}[t]
\begin{lstlisting}
runApp action cfg initState =
  runLift . runState initState . runReader action $ cfg
\end{lstlisting}
\caption{Обработка эффектов и запуск приложения}
\label{listing:ftRun}
\end{figure}

\chapter{Монадические парсеры}

В девяностые годы двадцатого века были опубликованы результаты исследований,
показывающих монадичекую природу функциональных парсеров~\autocite{WadlerMonads}. 
Эта особенность парсеров приносит практические плоды: использование 
монадического комбинатора связывания позволяет удобно строить композиции 
парсеров.

Дальнейшее развитие монадического подхода к построению парсеров делает возможным
выражение цельной монады для парсера в терминах более фундаментальных монад, что
обеспечивает большую модульность архитектуры и позволяет варьировать семантику
парсера за счёт изменения внутренней монады стека: создавать недетерменированные
парсеры, парсеры, сигнализирующие о некорректности исходного текста, парсеры,
генерирующие сообщения об ошибках.

\section{Классический подход к построению монады Parser}

Большая часть содержимого этого подраздела является изложением первого радела
статьи~\autocite{MonParsing}.

Функциональный стиль построения парсеров заключается в том, что парсер
представляется функцией, которая принимает на вход строку символов и строит
по ней некое абстрактное синтаксическое дерево. Удобно считать, что не каждый 
парсер полностью потребляет входную строку, это одно из условия для возможности 
построения результирующего парсера по частям, из примитивных. Также необходимо 
иметь средства для обработки некорректного входа. Для этого существуют разные 
способы: можно сообщать об ошибке разбора, либо заменять неудачу списком 
успехов~\autocite{WadlerSuccess}. Высказанные пожелания о характеристиках 
парсера могут быть отражены следующим типом языка Haskell:

\begin{figure}[h]
\begin{lstlisting}
type Parser a = String -> [(a,String)]
\end{lstlisting}
\caption{Тип Parser}
\end{figure}

Мотивацией для приложения монад к построению парсеров является неудобность 
композиции немонадических парсеров, приводящая к появлению вложенных кортежей:

\begin{figure}[h]
\begin{lstlisting}
seq :: Parser a -> Parser b -> Parser (a,b)
p `seq` q = \inp -> [((v,w),inp'') | (v,inp')  <- p inp
                                   , (w,inp'') <- q inp']
\end{lstlisting}
\caption{Комбинатор для построения композиции парсеров}
\end{figure}

В листинге~\ref{listing:MonadParser} приведён экземпляр класса типов Monad для 
типа Parser:

\begin{figure}[t]
  \begin{lstlisting}
instance Monad Parser where
  return t = Parser $ \s -> Just (t, s)
  m >>= k  = Parser $ \s -> do
                              (u, v) <- parse m s
                              (x, y) <- parse (k u) v
                              return (x, y)
  \end{lstlisting}
  \caption{Зкземпляр Monad для Parser}
  \label{listing:MonadParser}
\end{figure}

Операция \lstinline{>>=}, известная как монадическое связывание 
(\lstinline{bind}), является удобным средством для построения композиции 
парсеров, её использование позволяет избежать неконтролируемого возникновения
вложенных кортежей, за счёт прямой передачи выхода первого парсера на вход
второго.

Приведём простейшие примеры парсеров.

\begin{figure}[h]
  \begin{lstlisting}
item :: Parser Char
item =  Parser f
        where f []     = []
              f (x:xs) = [(x,xs)]
  \end{lstlisting}
  \caption{Парсер \lstinline{item} в случае цельной монады}
  \label{listing:ParserItem}
\end{figure}

В листинге~\ref{listing:ParserItem} представлен базовый парсер \lstinline{item},
его задача заключается в отделении одного символа от входной строки. Именно его
реализация требует активной эксплуатации средств, определяемых конкретным типом,
представляющим парсер. Это значит, что реализация парсера \lstinline{item} для
цельной монады \lstinline{Parser} отличается от той, что будет уместна в случае
использования средств комбинирования монад.

\section{Построение монады Parser как комбинации более простых монад}

Рассмотренная в предыдущем подразделе монада \lstinline{Parser} не является
едиснтвенным примером монады. В статье~\autocite{WadlerMonads} Philip Wadler
приводит примеры типов, имеющих моноидальную структуру.
В статье~\autocite{MonParsing} описан способ представить тип из
листинга~\ref{listing:MonadParser} в виде комбинации монад \lstinline{State}
и \lstinline{[]}, для этого применяется механизм трансформеров монад.

\subsection{Подход с трансформерами монад}

Как уже говорилось ранее, монада \lstinline{Parser} из предыдущего подраздела 
может быть представлена в виде комбинации двух более простых монад 
(см. листинг~\ref{listing:MonadTransParser})

\begin{figure}[h]
\begin{lstlisting}
type Parser a = StateT String [] a
\end{lstlisting}
\caption{Тип Parser как комбинация монад State и []}
\label{listing:MonadTransParser}
\end{figure}

Благодаря трансформерам монад к этому типу могут быть добавлены и другие 
вычислительные эффекты, такие как, например, конфигурационная информация и 
журнализация. Внутренняя монада может быть изменена: вместо списковой монады, 
описывающей недетерминированный парсер, можно использовать монаду 
\lstinline{Maybe} или \lstinline{Either a} для получения парсера, выдающего 
сообщение об ошибке в случае неудачного разбора. Таким образом, благодаря 
трансформерам монад становится доступна такая гибкости управления типом парсера,
достичь которой было бы тяжело при явном описании монады \lstinline{Parser}.

Монадический код имеет высокий уровень абстракции. Это приносит ценные 
практические плоды: код парсера, написанных для одного стека монад с высокой 
вероятностью может быть без изменений перенесён на другой стек. Принципиальных 
изменений требует только самый базовый парсер \lstinline{item}, который напрямую
работает со структурой стека монад. В листингах~\ref{listing:MonadTransItem1}
и~\ref{listing:MonadTransItem2} представлены примеры базового парсера для двух
стеков монад: простого и более сложного, используемого в библиотеке для
парсинга \lstinline{Markdown}, которая будет описана в следующем разделе.

\begin{figure}[t]
\begin{lstlisting}
type Parser a = StateT String [] a

item :: Parser t Char
item = do
  state <- get
  case state of
    []     -> []
    (x:xs) -> put xs >> return c
\end{lstlisting}
\caption{Простой тип Parser}
\label{listing:MonadTransItem1}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}
newtype Parser t a = Parser (StateT (ParserState t) 
                            (Either (ErrorReport t)) a)

item :: TM.TextualMonoid t => Parser t Char
item = do
  state  <- get
  let s = TM.splitCharacterPrefix . remainder $ state
  case s of
    Nothing -> throwError (EmptyRemainder "item",state)
    Just (c,rest) -> do
      let (c,rest) = fromJust s
      put (ParserState { position = updatePos (position state) c, 
                         remainder = rest })
      return c
\end{lstlisting}
\caption{Парсер с поддержкой моноидального входного потока и отслеживанием ошибок}
\label{listing:MonadTransItem2}
\end{figure}

В парсере \lstinline{item} из листинга~\ref{listing:MonadTransItem2} является 
обобщённым по типу входных данных: использование класса типов 
\lstinline{TextualMonoid} из библиотеки \lstinline{monoid-subclasses} позволяет
использовать этот парсер для любых строковых типов. В случе неудачного разбора 
генерируется ошибка, сообщающая о пустой входной строке и содержащая последнее
корректное состояние парсера, которое включает в себя позицию и оставшуюся 
входную последовательность.   

\subsection{Подход с расширяемыми эффектами}

Библиотека \lstinline{Extensible Effects} предоставляют по крайней мере два 
способа комбинирования вычислительных эффектов для описания монадических 
парсеров: явное статическое описание набора эффектов и указание эффектов в типе
каждой функции парсера.

В первом подходе чувствуется влияние траснформеров монад, и он не позволяет 
воспользоваться всеми преимуществами расширяемых эффектов. 
В листинге~\ref{listing:ExtEffectsParser} представлен тип для парсера со 
статическим набором эффектов и функция для обработки эффектов.

\begin{figure}[h]
\begin{lstlisting}
type Parser a = Eff (Fail :> State String :> Void)

parse p inp = run . runFail . runState inp $ p
\end{lstlisting}
\caption{Тип Parser как статически заданный набор эффектов}
\label{listing:ExtEffectsParser}
\end{figure}

Второй способ не подразумевает описание какого-либо специального типа для 
парсера. Каждая функция-парсер имеет свой собственный набор эффектов, 
ограниченный снизу набором эффектов базового парсера \lstinline{item} 
(листинг~\ref{listing:ExtEffectsItem}).

\begin{figure}[h]
\begin{lstlisting}
item :: ( Member Fail r
        , Member (State String) r
        ) => Eff r Char
item = do s <- get
          case s of
            [] -> die
            (x:xs) -> put xs >> return x
\end{lstlisting}
\caption{Возможный вариант парсера \lstinline{item} и его эффекты}
\label{listing:ExtEffectsItem}
\end{figure}

На основе парсера \lstinline{item} строятся другие парсеры. 
В листинге~\ref{listing:ExtEffectsSat} представлен парсер для символа, 
удовлетворяющего предикату.

\begin{figure}[h]
\begin{lstlisting}
sat :: ( Member Fail r
       , Member (State String) r
       ) => (Char -> Bool) -> Eff r Char
sat p = do x <- item
           if p x then return x else die
\end{lstlisting}
\caption{Распознавание символа по предикату}
\label{listing:ExtEffectsSat}
\end{figure}

Набор эффектов парсера более высокого уровня не обязан ограничиваться эффектами
парсера \lstinline{item}, в листинге~\ref{listing:ExtEffectsMpus} представлен
парсер для букв, определённый с помощью эффекта недетерминированного выбора,
парсеры \lstinline{lower} и \lstinline{upper} определены через парсер
\lstinline{sat}. Эффект \lstinline{Choose} предоставляет функции
\lstinline{mzero'} и \lstinline{mplus'}, аналогичные интерфейсу класса типов
\lstinline{MonadPlus}. Стандартном поведением для этих функций является
недетерминированный выбор: результаты применения парсеров склеиваются в список.

\begin{figure}[t]
\begin{lstlisting}
letter :: ( Member Fail r
          , Member (State String) r
          , Member (Choose) r
          ) => Eff r Char
letter = lower `mplus'` upper
\end{lstlisting}
\caption{Парсер с расширенным относительно \lstinline{item} набором эффектов}
\label{listing:ExtEffectsMpus}
\end{figure}

Все заявленные эффекты должны быть обработаны. Библиотека парсеров, основанная
на расширяемых эффектах, должна предоставлять соответсвуюющий набор функция
для запуска вычислений. В листинге~\ref{listing:ExtEffectsRunners} представлены
две функции, позволяющие использовать описанные выше парсеры.

\begin{figure}[t]
\begin{lstlisting}
parse p inp = run . runFail . runState inp $ p

parseWithChoose p inp =
  run . runChoice . runFail . runState inp $ p
\end{lstlisting}
\caption{Функции для запуска парсеров с разными наборами эффектов}
\label{listing:ExtEffectsRunners}
\end{figure}

Построение библиотек монадических парсеров с использованием расширяемых эффектов
имеет несколько иную специфику, чем с использованием трансформеров монад. С
одной стороны, расширяемые эффекты предоставляют большую гибкость: каждый парсер
имеет свой собственный набор эффектов. С другой стороны, механизм трансформеров
монад имеет удобную поддержку со стороны компилятора \lstinline{GHC}, которая
обеспечивает автоматическое порождение экземпляров нужных классов типов, таких
как, например, \lstinline{MonadPlus}, \lstinline{Applicative} и
\lstinline{Alternative}, что избавляет разработчика от необходимости описывать
некоторые вспомогательные функции. Таким образом, концептуально расширяемые
эффекты являются более интересным средством, но трансформеры монад удобнее для
прикладного программирования.

\newpage

\chapter{Функциональный парсер языка Markdown}

Язык \lstinline{Markdown} --- легковесный язык разметки, применяется для быстрой
вёрстки небольших документов. Полезен в случаях, когда нет необходимости привлекать
такие тяжеловесные форматы как \lstinline{HTML} и \lstinline{LaTeX}. Популярен в
интернете, к примеру, на известном хостинге программного кода
\lstinline{GitHub}.

\section{Синтаксис Markdown}

В отличие от \lstinline{HTML} или \lstinline{XML}, \lstinline{Markdown} не имеет
стандарта. Существует неформальное, но подробное описание базового
синтаксиса~\autocite{MarkdownSyntax}, а также нескольких расширенных версий, в
числе которых так называемый \lstinline{GitHub Flavored Markdown}.

В реализуемом парсере рассматривается подмножество базового синтаксиса,
включающее в себя заголовки, параграфы, неупорядоченные списки и блочные цитаты.
Дополнительной возможностью являются вставки математических формул в формате
\LaTeX.

\section{Реализация парсера}

Язык программирования \lstinline{Haskell} известен своей развитой системой
типов. Аппарат алгебраических типов данных предоставляет удобные средства для
представления абстрактного синтаксического дерева. Любой 
\lstinline{Markdown}-документ представляет собой список блоков. Блок
представляется типом-суммой, конструкторы которого отражают рассматриваемое
подмножество \lstinline{Markdown}. В листинге~\ref{listing:MarkdownADT}
представлены типы, описывающие рассматриваемую грамматику.

\begin{figure}[t]
\begin{lstlisting}
type Document = [Block]

data Block = Blank
           | Header (Int,Line)
           | Paragraph [Line]
           | UnorderedList [Line]
           | BlockQuote [Line]
  deriving (Show,Eq)

data Line = Empty | NonEmpty [Inline]
  deriving (Show,Eq)

data Inline = Plain String
            | Bold String
            | Italic String
            | Monospace String
  deriving (Show,Eq)
\end{lstlisting}
\caption{Грамматика рассматриваемого подмножества \lstinline{Markdown}}
\label{listing:MarkdownADT}
\end{figure}

Блоком является либо пустой блок, либо заголовок, либо параграф, либо
неупорядоченный список, либо блочная цитата. Большинство блоков имеют в своём
составе список строк. Строка распадается на строчные элементы, дифференцируемые
по стилю начертания: простые, полужирные, курсивом и моноширинные.
В листинге~\ref{listing:MarkdownInline} представлены парсеры для распознавания
строк, парсеры \lstinline{bold}, \lstinline{italic} и \lstinline{plain}
аналогичны парсеру \lstinline{monospace}, поэтому опущены для краткости.

При реализации парсеров активно применяются комбинаторы из библиотек, принцип
построения которых был описан в предыдущих разделах. Стоит подробнее остановится
на трёх из них, их типовые аннотации приведены в 
листинге~\ref{listing:ParserCombinators}:

\begin{figure}[h]
\begin{lstlisting}
many :: Parser t a -> Parser t [a]

sepby :: Parser t a -> Parser t b -> Parser t [a]

bracket :: Parser t a -> Parser t b -> Parser t c -> Parser t b
\end{lstlisting}
\caption{Типовые аннотации основных комбинаторов парсеров}
\label{listing:ParserCombinators}
\end{figure}

\begin{enumerate}
  \item Комбинатор \lstinline{many} распознаёт список токенов, удовлетворяющих
  его парсеру-параметру.
  \item Комбинатор \lstinline{sepby} распознаёт последовательность токенов,
  удовлетворяющих его первому параметру и разделённых токенами, удовлетворяющими 
  его второму параметру.
  \item Комбинатор \lstinline{bracket} распознаёт токены, удовлетворяющие его
  третьему парасетру и заключенные между токенами, удовлетворяющими первому и
  третьему соответственно.
\end{enumerate}

\begin{figure}[t]
\begin{lstlisting}
line :: TM.TextualMonoid t => Parser t Line
line = emptyLine `mplus` nonEmptyLine

emptyLine :: TM.TextualMonoid t => Parser t Line
emptyLine = many (sat wspaceOrTab) >> char '\n' >> return Empty

nonEmptyLine :: TM.TextualMonoid t => Parser t Line
nonEmptyLine = do
  many (sat wspaceOrTab)
  l <- sepby1 (bold <|> italic <|> 
               plain <|> monospace) (many (char ' '))
  many (sat wspaceOrTab)
  char '\n'
  return . NonEmpty $ l

monospace :: TM.TextualMonoid t => Parser t Inline
monospace = do
  txt <- bracket (char '`') sentence (char '`')
  p   <- many punctuation
  return . Monospace $ txt ++ p
\end{lstlisting}
\caption{Распознавание строк из строчных элементов.}
\label{listing:MarkdownInline}
\end{figure}

Получив возможность распознавать строки и внутристрочные элементы, можно приступить к реализации парсеров для блоков. В листинге~\ref{listing:MarkdownHeader} представлен парсер для заголовка, а в листинге~\ref{listing:markdownUlist} --- для неупорядоченного списка, парсеры для остальных блоков описываются схожим образом. Здесь следует сделать замечание, что текущая версия парсера не поддерживает вложенные списки, оформляемые в \lstinline{Markdown} с помощью отступов.

\begin{figure}[t]
\begin{lstlisting}
header :: TM.TextualMonoid t => Parser t Block
header = do
  hashes <- token (some (char '#'))
  text <- nonEmptyLine
  return $ Header (length hashes,text)
\end{lstlisting}
\caption{Парсер для заголовка}
\label{listing:MarkdownHeader}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}
unorderdList :: TM.TextualMonoid t => Parser t Block
unorderdList = do
  items <- some (token bullet >> line)
  return . UnorderedList $ items
  where
    bullet :: TM.TextualMonoid t => Parser t Char
    bullet = char '*' <|> char '+' <|> char '-' >>= return
\end{lstlisting}
\caption{Парсер для неупорядоченного списка}
\label{listing:markdownUlist}
\end{figure}

\lstinline{Markdown} применяется также для электронного конспектирования и
оформления заданий. Полезным расширением грамматики \lstinline{Markdown}
являются вставки матетических формул в формате \LaTeX. Требуется распознать
\LaTeX-блок и оставить его без изменений, чтобы при последующей генерации кода
по абстрактному синтаксическому дереву можно было отобразить его соответствующим
образом. Для этого служит парсер из листинга~\ref{listing:MarkdownLaTeX}.

\begin{figure}[h]
\begin{lstlisting}
blockMath :: TM.TextualMonoid t => Parser t Block
blockMath = 
  (bracket (string "$$") (some (sat (/= '$'))) (string "$$")) >>= 
  return . Paragraph . (: []) . NonEmpty . (: []) . Plain .
    (\x -> "$$" ++ x ++ "$$")
\end{lstlisting}
\caption{Парсер \LaTeX-блоков}
\label{listing:MarkdownLaTeX}
\end{figure}

В листинге \ref{listing:MarkdownDoc} представлен парсер самого верхнего уровня,
служащий для распознавания \lstinline{Markdown}-документа как списка блоков.

\begin{figure}[h]
\begin{lstlisting}
doc :: TM.TextualMonoid t => Parser t Document
doc = many block
  where block = blank <|> header <|> paragraph <|>
                unorderdList <|> blockquote <|> blockMath
\end{lstlisting}
\caption{Парсер, распознающий \lstinline{Markdown}-документ}
\label{listing:MarkdownDoc}
\end{figure}

\section{Генерация HTML-кода}

Имея абстрактное синтаксическое дерево \lstinline{Markdown}-документа можно
сгенерировать по нему исходный текст на любом требуемом языке разметки.
В качестве целевого языка разметки был выбран \lstinline{HTML}, для рендеринга
\LaTeX-вставок используется \lstinline{JavaScript}-библиотека
\lstinline{MathJax}~\autocite{MathJax}. Возможно построения генераторов и для
других языков разметки.

Генерация кода происходит от общего к частному. Функция \lstinline{serialize}
генерирует код по списку блоков и конкатенирует результат. Генерация каждого 
блока производится функцией \lstinline{genBlock}, которая соответствующим
образом обрабатывает все поддерживаемые виды блоков и генерирует нужный код. 
Строки и втнутристрочные элементы генерируются функциями \lstinline{genLine} и 
\lstinline{genInline} соответственно.

В листинге~\ref{listing:HTMLGen} представлен сокращённый кодогенератор, опущена,
для краткости, обработка некоторых блоков и внутристрочных элементов, которая
происходит аналогично представленным. Этот код служит демонстрацией
выразительности, которая предоставляется сопоставлением с образцом и
алгебраическими типами данных.

\begin{figure}[h]
\begin{lstlisting}
serialize :: Document -> String
serialize = concatMap genBlock

genBlock :: Block -> String
genBlock Blank = "\n"
genBlock (Header h) =
  "<h" ++ s ++ ">" ++ genLine (snd h) ++ "</h" ++ s ++ ">" ++ "\n"
    where s = show (fst h)
genBlock (UnorderedList l) =
  "<ul>" ++ concatMap ((++ "\n") . genOrderedListItem) l ++ "</ul>" ++ "\n"

genLine :: Line -> String
genLine Empty         = ""
genLine (NonEmpty []) = genLine Empty ++ "\n"
genLine (NonEmpty l)  = concatMap ((++ " ") . genInline) l

genOrderedListItem :: Line -> String
genOrderedListItem l = "<li>" ++ genLine l ++ "</li>"

genInline :: Inline -> String
genInline (Plain s) = s
genInline (Monospace s) = "<code>" ++ s ++ "</code>"
\end{lstlisting}
\caption{Генерация \lstinline{HTML}}
\label{listing:HTMLGen}
\end{figure}

Полный исходный код парсера \lstinline{Markdown}, кодогенератора, а также вспомогательной библиотеки комбинаторов парсеров доступен в репозитории~\autocite{MDParse}. 

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
