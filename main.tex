% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

% Выделение красным для TODO в pdf 
\newcommand\todo[1]{\textcolor{red}{#1}} 

 % Временный сепоратор для разделов введения, должен выглядеть устрашающе
\newcommand\sep{\rule{4cm}{0.4pt}}

% Рамочка вокруг фигур
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\begin{document}

\Intro
В данной работе рассматривается задача синтаксического анализа
файлов в формате Markdown с применением технологий функционального
программирования. В качестве языка реализации используется Haskell.
Синтаксический анализ текстов, таких как, например, исходные коды на языках программирования --- задача,поставленная ещё на самых ранних этапах развития информатики. Традиционные методы решения этой задачи, описанные, например, в книге~\autocite{DragonBook2}, используют императивный подход. 

\section{Предварительные сведения}

\subsection{Особенности императивного подхода}

Что-то про императивный подход

В этой работе используются методы функционального подхода к программированию, одними из основных достоинств которого является высокий уровень абстракции и большая информативность кода.

\subsection{Использованные в работе технологии фукционального программирования}

Функциональное программирование --- парадигма программирования, стиль построения структуры и элементов компьютерных программ, которая трактует вычисления как вычисление значения некоторой математической функции и избегает изменяемого состояния.

Корни функционального программирования уходят в $\lambda$-исчисление, формальную систему, разработанную в 1930-х годах для решения Entscheidungsproblem~\autocite{Entscheidungsproblem}.

Одним из главных преимуществ функциональных языков программирования считается высокий уровень абстракции,большая выразительность и высокий коэффициент повторного использования кода. Для достижения этих свойств в языках реализуются такие средства как параметрический полиморфизм, функции высших порядков, алгебраические типы данных, классы типов и некоторые другие. Использование неизменяемых явно данных позволяет существенно упростить распараллеливание программ. 

\subsubsection{Функции высших порядков}
Ключевой концепцией функционального программирования являются так называемые функции высших порядков (higher-order function). Они представляют собой функции, в качестве параметров которых могут выступать другие функции. 

\begin{description}
  \item[Пример] 
  Рассмотрим одну из функций стандартной библиотеки языка Haskell: 
  \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]

    ghci> map (+3) [1,5,3,1,6]  
    [4,8,6,4,9]
  \end{lstlisting}
  Как видно из типовой аннотации, она принимает на вход функцию, преобразующую значение типа a к значению типа b, и список значений типа b, возвращаемым значением является список результатов применения функции к значениям из входного списка.  
\end{description}

Функция, рассмотренная в примере, обладает ценным свойством: она является полиморфной по своему параметру и выходному значению. Возможность написания параметрически полиморфных функций позволяет при программировании на Haskell повысить повторное использование кода и выразительность, чему способствует также простота синтаксиса, применяемого для описания таких функций.     

\subsubsection{Алгебраические типы данных}

Алгебраические типы данных --- минималистический, но мощный способ описания типов данных, применяемый в функциональных языках программирования. Выделяют типы-перечисления или типы-суммы -- аналог перечислений enum из императивных языков, и типы-контейнеры или типы-произведения, аналог структур struct или записей record.

\begin{description}
  \item[Пример] 
  Рассмотрим простой тип-сумму, используемый в языке Haskell для представления булевых констант: 
  \begin{lstlisting}
    data Bool = False | True  

  \end{lstlisting}
  Этот тип распадается на два конструктора значений (value constructors), экземпляр значения типа Bool может являться одним из возможных значений (True или False).
\end{description}

\begin{description}
  \item[Пример] 
  Теперь рассмотрим тип-произведение и пример создание константы этого типа: 
  \begin{lstlisting}
    data Person = Person {
      firstName :: String
      , lastName :: String
      , age :: Int
    --Usage
    let p = Person {firstName="John", 
                    lastName="Lennon", 
                    age=43}
  \end{lstlisting}
\end{description}

Алгебраические типы данных могут быть параметризованы -- это позволяет создавать, например, полиморфные контейнеры.

\begin{description}
  \item[Пример] 
  Рассмотрим определение списка, аналогичное определению из стандартной библиотеки языка Haskell:
  \begin{lstlisting}
    data List a = Nil | Cons a (List a)
  \end{lstlisting}
  Здесь List является конструктором типа (type constructor) с одним типовым параметром, а Nil и Cons --- конструкторами значений. Стоит также заметить, что List является рекурсивным типом.
\end{description}

\subsubsection{Классы типов}

Классы типов позволяют накладывать ограничения на параметрически полиморфные типы, определяя некоторый набор операций, которые могут производиться над типами, принадлежащими к этому классу. Иными словами, класс типов определяет интерфейс, через который можно взаимодействовать с типом.

\begin{description}
  \item[Пример] 
  Рассмотрим определение стандартного класса типов языка Haskell, отвечающего за возможность сравнения на равенство:
  \begin{lstlisting}
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
  \end{lstlisting}
\end{description}

Чтобы воспользоваться возможностями класса типов для какого-то конкретного типа не обходимо объявить этот тип экземпляром класса типов, во многих случаях это может быть сделано неявно, благодаря автоматическому порождению экземпляров в компиляторе GHC

\begin{description}
  \item[Пример] 
  Возможность автоматического порождения экземпляра нужного класса типов для алгебраического типа данных:
  \begin{lstlisting}
    data Numbers = One | Two | Three 
      deriving (Eq)
  \end{lstlisting}
\end{description}

В некоторых случаях необходимо описать экземпляр явно, такая возможность тоже существует.

\begin{description}
  \item[Пример] 
  Явное описание экземпляра:
  \begin{lstlisting}
    data Foo = Foo {x :: Integer, str :: String}
 
    instance Eq Foo where
      (Foo x1 str1) == (Foo x2 str2) = (x1 == x2) && 
                                       (str1 == str2)
  \end{lstlisting}
\end{description}

Как уже говорилось ранее, код, написанный на языке программирования Haskell имеет очень высокий уровень абстракции. Далее будут рассмотрены два классы типов, представляющие структуры, введённые в язык Haskell под влиянием исследований в области связи теоретической информатики и теории категорий. Принято считать, что эти структуры представляют хорошую абстракцию для вычислений в смысле. В дальнейшем изложении эти классы типов будут постоянно использоваться для построения парсеров. 

\subsubsection{Функтор}

Рассмотрим определение класса типов Functor из стандартной библиотеки Haskell:

\begin{lstlisting}
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{lstlisting}

Как видно из определения, каждый тип, являющийся функтором, должен предоставлять одну функцию. Сформировались две основные интуитивные трактовки функтора: контейнер, содержащий в себе значения определённого типа и вычисление, которое производится в некотором контексте. Согласно первой из этих трактовок, функция fmap применяет подаваемую ей на вход функцию к значению в контейнере и возвращает изменённое значение, с сохранением структуры контейнера. Если же говорить в терминах вычислительных контекстов, то fmap модифицирует вычисление в контексте, но сам контекст остаётся неизменным.

Упомянутые выше списки языка Haskell являются функторами, для них в качестве fmap можно выбрать функцию map. 

Важно заметить, что не любой тип, для которого определена функция fmap является функтором, необходимо также потребовать выполнения двух уравнений, называемых законами функтора:

\begin{lstlisting}
  fmap id = id
  fmap (g . h) = (fmap g) . (fmap h)
\end{lstlisting}

Здесь id --- тождественная функция, а . --- инфиксный оператор композиции функций. Эти уравнения отражают теоретико-категорное определение функтора как отображения между категориями, сохраняющее единичный морфизм и композицию. В случае Haskell рассматриваются эндофункторы над категорией Hask --- категорией типов языка Haskell.  

\subsubsection{Монада}

\subsection{Существующие библиотеки функциональных парсеров}

\section{Комбинирование Вычислительный Эффектов}

\subsection{Комбинирование Функторов}

\subsection{Трансформеры Монад}

В статье~\autocite{MonadTransformers} описаны объекты, трансформеры монад, которые можно использовать в качестве строительных блоков для построения типов, описывающих вычисления с побочными эффектами. Каждый из трансформеров монад позволяет добавить некоторый вычислительный эффект к внутренней монаде, при этом для результирующего типа также возможно построение экземпляра класса типов~\lstinline{Monad}.

На данный момент трансформеры монад являются общепринятым способом построения монадических вычислений с несколькими побочными эффектами. Тем не менее, эта техника имеет признанные недостатки: проблема невозможности автоматического \emph{подъёма} (~\lstinline{lift}) при наличии в стеке двух эффектов одного рода, связанная с первой проблема статически определённого порядка эффектов в стеке, а также невозможность скомбинировать две произвольные монады. 

В листинге~\ref{listing:mtlReadersLift} приведён пример монадической функции, которая должна иметь два различных конфигурационных параметра. Если не произвести явный подъём, то компиляция этой функции завершится с ошибкой проверки типов вида~\ref{listing:mtlCompileError}: компилятор не в состоянии самостоятельно вывести нужный тип для функции~\lstinline{ask}.

\begin{figure}[t]
\begin{lstlisting}
adder :: ReaderT String (Reader Int) Int
adder = do
  str <- ask
  num <- lift ask
  return $ num + read str

runnerForAdder = runReader (runReaderT adder "2") 3
\end{lstlisting}
\caption{Необходимость явного подъёма во внутреннюю монаду}
\label{listing:mtlReadersLift}
\end{figure}

Порядок монад в стеке опредлён статически и закодировал в типе функции, в листинге~\ref{listing:mtlDifferentReadersLift} представлена та же функция, эквивалентная по смыслу, но имеющая другой тип. Значительной деталью также является тот факт, что в реализации этой функции~\lstinline{lift} применяется к другому вызову функции~\lstinline{ask}. 

\begin{figure}[t]
\begin{lstlisting}
adder :: ReaderT Int (Reader String) Int
adder = do
  str <- lift ask
  num <- ask
  return $ num + read str

runnerForAdder = runReader (runReaderT adder 3) "2"
\end{lstlisting}
\caption{Функция из листинга~\ref{listing:mtlReadersLift} с другим порядком монад в стеке}
\label{listing:mtlDifferentReadersLift}
\end{figure}

Функция~\lstinline{runnerForAdder} из листингов \ref{listing:mtlReadersLift} и \ref{listing:mtlDifferentReadersLift}, запускающая вычисление, полностью определяется типом вычисления, она производит развёртку стека монад. В следующем подразделе будет рассмотрено средство комбинирования вычислительных эффектов, при использовании которого порядок на наборе эффектов устанавливается именно функцией, запускающей вычисление, а сам набор является неупорядоченным.     

\begin{figure}[t]
\begin{lstlisting}
No instance for (MonadReader Int (ReaderT String (Reader Int)))
      arising from a use of ask
\end{lstlisting}
\caption{Ошибка типов при отсутствии явного подъёма}
\label{listing:mtlCompileError}
\end{figure}

Следует сделать замечание относительно предыдущего примера: разнородная конфигурационная информация могла быть объединена в алгебраический тип данных, и тогда нужда в использовании двух эффектов~\lstinline{Reader} отпала бы, однако такое решение может не сработать для других эффектов, поэтому необходимо искать универсальный способ. 

Здесь можно привести что-нибудь про невозможность скомбинировать две произвольные монады. Пока есть приложение к статье~\autocite{ComposingMonads} и пост на стековерфлоу~\autocite{SOMonadsComposition}.

Ведутся активные поиски способов комбинирования монад, которые были бы лишены вышеперечисленных недостатков. Одним из развивающихся направлений являются расширяемые эффекты (~\lstinline{Extensible Effects}), речь о которых пойдёт в следующем подразделе.

\subsection{Расширяемые эффекты}

Этот подраздел посвящён альтернативному трансформерам монад способу комбинирования вычислительных эффектов, представленному в статье~\autocite{ExtEffects}. 

\subsubsection{Краткое описание библиотеки \lstinline{Extensible Effects}}

Суть подхода заключается в аналогии между вычислительными эффектами и клиент-серверным взаимодействием. Код, который собирается породить некоторый побочный эффект: совершить ввод-вывод, бросить исключение и т.п. должен отправить \emph{запрос} на обработку этого эффекта \emph{авторитету}. Запрос описывает действие, которое необходимо произвести, а также особую функцию, \emph{continuation}, (TODO: мб заменить) для продолжения вычисления после обработки запроса. 

В ранних разработках, относящихся к такому подходу, авторитет --- интерпретатор запросов --- не был частью программы пользователя, а являлся отдельной сущностью, подобно ядру операционной системы, или обработчику~\lstinline{IO}-действий в ~\lstinline{Haskell}. Этот глобальный внешний авторитет имел контроль над всеми ресурсами (файлами, памятью и т. п.): он обрабатывал запрос и принимал решение: исполнить его и продолжить выполнение запросившего кода, либо остановить вычисление и вернуть результат. При таком подходе нет никакой необходимости в указании явного порядка при комбинировании эффектов, однако недостатком является негибкость внешнего интерпретатора эффектов, кроме того, эффекты никак не отражаются в типах.

Разработчики библиотеки~\lstinline{Extensible Effects} модифицировали концепцию: 

\begin{itemize}
  \item 
Глобальный обработчик запросов был заменён на средство, которое является частью пользовательской программы, некий аналог обработчиков исключений: теперь вместо единого авторитета для всех эффектов существуют частичные авторитеты для каждого типа эффектов, такой подход называется \emph{алгебраическими обработчиками}. Каждый такой обработчик является авторитетом для соответствующей клиентской части программы, а также и клиентом сом по себе: он пересылает запросы, которые не может обработать, обработчику более верхнего уровня. 
  \item 
Разработана выразительная система типов-эффектов, которая отслеживает какие эффекты активны в данном вычислении. Эта система поддерживает особую структуру данных: \emph{открытое объединение} (\lstinline{Open Union}, индексированное типами копроизведение функторов), содержащее неупорядоченный набор вычислительных эффектов. Действие каждого обработчика отражается в типе удаление из этого набора эффекта, который был обработан, таким образом система типов может отследить, все ли эффекты обработаны. 
  \item 
Синтаксис для работы с эффектами построен по аналогии с синтаксисом для трансфомеров монад и код, написанный с их использованием, может быть переведённый на расширяемые эффекты с минимальными синтаксическими изменениями.  
\end{itemize} 

Есть два способа обозначить принадлежность эффекта \lstinline{m} открытому объединению \lstinline{r}. С помощью типового ограничения \lstinline{Member m r}, которое означает, что вычисления имеет \emph{по крайней мере} один побочный эффект \lstinline{m}. Иначе, можно явно указать шаблон \lstinline{m :> r'} разложения набора \lstinline{r} на эффект \lstinline{m} и оставшийся набор \lstinline{r'}, что аналогично теоретико-множественному обозначению $\{$\lstinline{m}$\}$ $\cup$ \lstinline{r'}. Тип \lstinline{Void} играет роль $\varnothing$, то есть вычисление с типом \lstinline{Eff Void a} является чистым, а вычисления с типом \lstinline{Eff (Reader Int :> Reader Bool :> Void)} может иметь побочный эффект обращения к двум средам конфигурационной информации.

Авторами также подмечается, что ограничение \lstinline{Member (Reader Int) r} выглядит похоже на ограничение принадлежности классу типов \lstinline{MonadReader}, более того, возможно объявить экземпляр этого класса для монады \lstinline{Eff r}. Однако в этом нет необходимости, так как тип \lstinline{Eff r} является более выразительным: в листинге \ref{listing:extEff2Readers} приводится пример работы с функцией, имеющей два эффекта \lstinline{Reader}. Эта функция демонстрирует одно из преимуществ расширяемых эффектов перед трансформерами монад: пропадает необходимость явного вызова функции \lstinline{lift}, которую можно наблюдать в листингах \ref{listing:mtlReadersLift} и \ref{listing:mtlDifferentReadersLift}. Каждое вхождение функции \lstinline{ask} обращается к своей собственной среде, определяемой типом. 

\begin{figure}[t]
\begin{lstlisting}
adder :: (Member (Reader Int) r
      ,   Member (Reader String) r) 
      =>  Eff r Int
adder = do
  num <- ask
  str <- ask
  return $ num + read str

runAdder = run $ runReader (runReader adder "2") (1 :: Int)
\end{lstlisting}
\caption{Пример функции с двумя средами конфигурации.}
\label{listing:extEff2Readers}
\end{figure} 

Другое важным отличие расширяемых эффектов от трансформеров монад --- неупорядоченность набора эффектов до запуска вычисления --- никак не проявило себя в примере из листинга \ref{listing:extEff2Readers}, потому что были использованы одинаковые эффекты. В листинге \ref{listing:extEffOrdering} рассмотрен синтетический (для краткости) пример, демонстрирующий динамическую установку порядка на множестве эффектов. Функция из примера считает до нуля и завершается с исключением. Если запускать вычисление в порядке, представленном в \lstinline{runCountdown1}, то результатом будет служить \lstinline{Nothing}, сообщающий об исключении. При запуске в порядке \lstinline{runCountdown2}, результатом будет пара \lstinline{(0,Nothing)} из последнего состояния и сообщения об исключении.      

\begin{figure}[t]
\begin{lstlisting}
finalCoutdown :: (Member Fail r
              ,  Member (State Int) r)
              =>  Eff r ()
finalCoutdown = do
  state <- get
  if state == (0 :: Int) 
  then die
  else put (state - 1) >> finalCoutdown 

runCountdown1 n = run $ runFail $ runState (n :: Int) $ finalCoutdown

runCountdown2 n = run $ runState (n :: Int) $ runFail $ finalCoutdown
\end{lstlisting}
\caption{Порядок на множестве эффектов определяется динамически}
\label{listing:extEffOrdering}
\end{figure} 

\subsubsection{Пример прикладного использования}

В этом подразделе будет рассмотрены некоторые составные части системной утилиты, написанной с использованием библиотеки \lstinline{Extensible Effects}. Задача этой утилиты --- отслеживание изменений содержимого некоторой директории и выполнение заданных сценариев командной оболочки в качестве реакции на эти изменения. Git-репозиторий с исходным кодом на языке \lstinline{Haskell} доступен по адресу \autocite{FileTrigger}. 

На этапе проектирования приложения необходимо определить, какие вычислительные эффекты будут им порождаться. Рассматриваемая утилита будет работать с файловой системой, значит не обойтись без эффекта \lstinline{IO}, иметь внутреннее состояние --- необходим эффект \lstinline{State}, а также будет иметь конфигурационную информацию --- потребуется эффекта \lstinline{Reader}.

\begin{figure}[t]
\begin{lstlisting}
loop :: (Member (Reader AppConfig) r, 
         Member (State AppState)   r, 
         SetMember Lift (Lift IO)  r) => Eff r ()
loop = do
  cfg <- ask 
  currentFilesList <- lift $ getFilesInfo $ directory cfg
  handleCreate currentFilesList
  lift $ threadDelay $ refreshRate cfg
  curTime <- lift getCurrentTime
  put $ (AppState currentFilesList curTime)
  loop
\end{lstlisting}
\caption{Главный цикл приложения}
\label{listing:ftMainLoop}
\end{figure}

В листинге \ref{listing:ftMainLoop} представлена упрощённая функция главного цикла программы, типовая аннотация отражает наличие в результирующем наборе эффектов \lstinline{r} трёх составляюших: \lstinline{Reader}, \lstinline{State} и \lstinline{IO}.

Как уже говорилось ранее, порядок на наборе эффектов устанавливается в момент запуска вычисления, для чего служит функция из листинга \ref{listing:ftRun}.

\begin{figure}[t]
\begin{lstlisting}
 runApp action cfg initState = 
  runLift . runState initState . runReader action $ cfg
\end{lstlisting}
\caption{Обработка эффектов и запуск приложения}
\label{listing:ftRun}
\end{figure}

\section{Монадические парсеры}

Большая часть содержимого этого раздела является вольным переводом статьи~\autocite{MonParsing}.

В девяностые годы двадцатого века были опубликованы результаты исследований, обсуждающие монадичекую природу функциональных парсеров. Эта особенность парсеров приносит практические плоды: использование монадического комбинатора связывания позволяет удобно строить композиции парсеров. 

Дальнейшее развитие монадического подхода к построению парсеров делает возможным выражение цельной монады для парсера в терминах более фундаментальных монад, что обеспечивает большую модульность архитектуры и позволяет варьировать семантику парсера за счёт изменения внутренней монады стека: создавать недетерменированные парсеры, парсеры, сигнализирующие о некорректности исходного текста, парсеры, генерирующие сообщения об ошибках.

\subsection{Классический подход к построению монады Parser}

Функциональный стиль построения парсеров заключается в том, что парсер представляется функцией, которая принимает на вход строку символов и строит по ней некое абстрактное синтаксическое дерево. Удобно считать, что не каждый парсер полностью потребляет входную строку, это одно из условия для возможности построения результирующего парсера по кусочкам, из примитивных. Также необходимо иметь средства для обработки некорректного входа. Для этого существуют разные подходы: можно сообщать об ошибке разбора, либо заменять неудачу списком успехов~\autocite{WadlerSuccess}. Высказанные пожелания о характеристиках парсера могут быть отражены следующим типом языка Haskell: 

\begin{figure}[h]
\begin{lstlisting}
type Parser a = String -> [(a,String)]
\end{lstlisting}
\caption{Тип Parser}
\end{figure}

Мотивацией для приложения монад к построению парсеров является неудобность композиции немонадических парсеров, приводящая к появлению вложенных кортежей: 

\begin{figure}[h]
\begin{lstlisting}
seq :: Parser a -> Parser b -> Parser (a,b)
p `seq` q = \inp -> [((v,w),inp'') | (v,inp')  <- p inp
                                   , (w,inp'') <- q inp']
\end{lstlisting}
\caption{Комбинатор для построения композиции парсеров}
\end{figure}

В листинге ~\ref{listing:MonadParser} приведён экземпляр класса типов Monad для типа Parser: 

\begin{figure}[t]
  \begin{lstlisting}
instance Monad Parser where
  return t = Parser $ \s -> Just (t, s)
  m >>= k  = Parser $ \s -> do 
                              (u, v) <- parse m s
                              (x, y) <- parse (k u) v
                              return (x, y)
  \end{lstlisting}
  \caption{Зкземпляр Monad для Parser}
  \label{listing:MonadParser}
\end{figure}

Операция \lstinline{>>=}, известная как монадическое связывание (bind), является удобным средством для построения композиции парсеров, её использование позволяет избежать неконтролируемого возникновения вложенных кортежей, за счёт прямой передачи выхода первого парсера на вход второго. 

Приведём простейшие примеры парсеров. 

\begin{figure}[h]
  \begin{lstlisting}
item :: Parser Char
item =  Parser f 
        where f []     = []
              f (x:xs) = [(x,xs)]
  \end{lstlisting}
  \caption{Парсер \lstinline{item} в случае цельной монады}
  \label{listing:ParserItem}
\end{figure}

В листинге~\ref{listing:ParserItem} представлен базовый парсер \lstinline{item}, его задача заключается в отделении одного символа от входной строки. Именно его реализация требует активной эксплуатации средств, определяемых конкретным типом, представляющим парсер. Это значит, что реализация парсера \lstinline{item} для цельной монады \lstinline{Parser} отличается от той, что будет уместна в случае использования средств комбинирования монад.

\subsection{Построение монады Parser как комбинации более простых монад}

Рассмотренная в предыдущем подразделе монада \lstinline{Parser} не является едиснтвенным примером монады. В статье~\autocite{WadlerMonads} Philip Wadler приводит примеры типов, имеющих моноидальную структуру. В статье~\autocite{MonParsing} описан способ представить тип из листинга~\ref{listing:MonadParser} в виде комбинации монад~\lstinline{State} и ~\lstinline{[]}, для этого применяется механизм трансформеров монад. 

\subsubsection{Подход с трансформерами монад}

Как уже говорилось ранее, монада~\lstinline{Parser} из предыдущего подраздела может быть представлена в виде комбинации двух более простых монад (см. листинг~\ref{listing:MonadTransParser})

\begin{figure}[h]
\begin{lstlisting}
type Parser a = StateT String [] a
\end{lstlisting}
\caption{Тип Parser как комбинация монад State и []}
\label{listing:MonadTransParser}
\end{figure}

Благодаря трансформерам монад к этому типу могут быть добавлены и другие вычислительные эффекты, такие как, например, конфигурационная информация и журнализация. Внутренняя монада может быть изменена: вместо списковой монады, описывающей недетерминированный парсер, можно использовать монаду~\lstinline{Maybe} или ~\lstinline{Either a} для получения парсера, выдающего сообщение об ошибке в случае неудачного разбора. Таким образом, благодаря трансформерам монад становится доступна такая гибкости управления типом парсера, достичь которой было бы тяжело при явном описании монады~\lstinline{Parser}.

Монадический код имеет высокий уровень абстракции. Это приносит ценные практические плоды: код парсера, написанных для одного стека монад с высокой вероятностью может быть без изменений перенесён на другой стек. Принципиальных изменений требует только самый базовый парсер \lstinline{item}, который напрямую работает со структурой стека монад. В листингах \ref{listing:MonadTransItem1} и \ref{listing:MonadTransItem2} представлены примеры базового парсера для двух стеков монад: простого и более сложного, используемого в библиотеке для парсинга \lstinline{Markdown}, которая будет описана в следующем разделе.  

\begin{figure}[t]
\begin{lstlisting}
type Parser a = StateT String [] a

item :: Parser t Char
item = do
  state <- get
  case state of
    []     -> []
    (x:xs) -> put xs >> return c  
\end{lstlisting}
\caption{Простой тип Parser}
\label{listing:MonadTransItem1}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}
newtype Parser t a = Parser (  
    StateT (ParserState t) (Either (ErrorReport t)) a)

item :: TM.TextualMonoid t => Parser t Char
item = do
  state  <- get
  let s = TM.splitCharacterPrefix . remainder $ state
  case s of 
    Nothing -> throwError (EmptyRemainder "item",state)
    Just (c,rest) -> do  
      let (c,rest) = fromJust s
      put (ParserState {position = updatePos (position state) c, remainder = rest})
      return c
\end{lstlisting}
\caption{Парсер с поддержкой моноидального входного потока и отслеживанием ошибок}
\label{listing:MonadTransItem2}
\end{figure}

\newpage

\subsubsection{Подход с расширяемыми эффектами}

Библиотека \lstinline{Extensible Effects} предоставляют по крайней мере два способа комбинирования вычислительных эффектов для описания монадических парсеров: явное статическое описание набора эффектов и указание эффектов в типе каждой функции парсера. 

В первом подходе чувствуется влияние траснформеров монад, и он не позволяет воспользоваться всеми преимуществами расширяемых эффектов. В листинге \ref{listing:ExtEffectsParser} представлен тип для парсера со статическим набором эффектов и функция для обработки эффектов.

\begin{figure}[h]
\begin{lstlisting}
type Parser a = Eff (Fail :> State String :> Void)

parse p inp = run . runFail . runState inp $ p 
\end{lstlisting}
\caption{Тип Parser как статически заданный набор эффектов}
\label{listing:ExtEffectsParser}
\end{figure}

Второй способ не подразумевает описание какого-либо специального типа для парсера. Каждая функция-парсер имеет свой собственный набор эффектов, ограниченный снизу набором эффектов базового парсера \lstinline{item} (листинг \ref{listing:ExtEffectsItem}).

\begin{figure}[h]
\begin{lstlisting}
item :: (Member Fail r
      ,  Member (State String) r) => Eff r Char
item = do s <- get
          case s of 
            [] -> die
            (x:xs) -> put xs >> return x 
\end{lstlisting}
\caption{Возможный вариант парсера \lstinline{item} и его эффекты}
\label{listing:ExtEffectsItem}
\end{figure}



\section{Реализация парсера языка Markdown} 

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
