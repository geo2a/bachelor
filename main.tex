% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

% Выделение красным для TODO в pdf 
\newcommand\todo[1]{\textcolor{red}{#1}} 

 % Временный сепоратор для разделов введения, должен выглядеть устрашающе
\newcommand\sep{\rule{4cm}{0.4pt}}

\begin{document}

\Intro
В данной работе рассматривается задача синтаксического анализа
файлов в формате Markdown с применением технологий функционального
программирования. В качестве языка реализации используется Haskell.
Синтаксический анализ текстов, таких как, например, исходные коды на языках программирования --- задача,поставленная ещё на самых ранних этапах развития информатики. Традиционные методы решения этой задачи, описанные, например, в книге~\autocite{DragonBook2}, используют императивный подход. 

\section{Особенности императивного подхода}

Что-то про императивный подход

В этой работе используются методы функционального подхода к программированию, одними из основных достоинств которого является высокий уровень абстракции и большая информативность кода.

\section{Использованные в работе технологии фукционального программирования}

Функциональное программирование --- парадигма программирования, стиль построения структуры и элементов компьютерных программ, которая трактует вычисления как вычисление значения некоторой математической функции и избегает изменяемого состояния.

Корни функционального программирования уходят в $\lambda$-исчисление, формальную систему, разработанную в 1930-х годах для решения Entscheidungsproblem~\autocite{Entscheidungsproblem}.

Одним из главных преимуществ функциональных языков программирования считается высокий уровень абстракции,большая выразительность и высокий коэффициент повторного использования кода. Для достижения этих свойств в языках реализуются такие средства как параметрический полиморфизм, функции высших порядков, алгебраические типы данных, классы типов и некоторые другие. Использование неизменяемых явно данных позволяет существенно упростить распараллеливание программ. 

\subsection{Функции высших порядков}
Ключевой концепцией функционального программирования являются так называемые функции высших порядков (higher-order function). Они представляют собой функции, в качестве параметров которых могут выступать другие функции. 

\begin{description}
  \item[Пример] 
  Рассмотрим одну из функций стандартной библиотеки языка Haskell: 
  \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]

    ghci> map (+3) [1,5,3,1,6]  
    [4,8,6,4,9]
  \end{lstlisting}
  Как видно из типовой аннотации, она принимает на вход функцию, преобразующую значение типа a к значению типа b, и список значений типа b, возвращаемым значением является список результатов применения функции к значениям из входного списка.  
\end{description}

Функция, рассмотренная в примере, обладает ценным свойством: она является полиморфной по своему параметру и выходному значению. Возможность написания параметрически полиморфных функций позволяет при программировании на Haskell повысить повторное использование кода и выразительность, чему способствует также простота синтаксиса, применяемого для описания таких функций.     

\subsection{Алгебраические типы данных}

Алгебраические типы данных --- минималистический, но мощный способ описания типов данных, применяемый в функциональных языках программирования. Выделяют типы-перечисления или типы-суммы -- аналог перечислений enum из императивных языков, и типы-контейнеры или типы-произведения, аналог структур struct или записей record.

\begin{description}
  \item[Пример] 
  Рассмотрим простой тип-сумму, используемый в языке Haskell для представления булевых констант: 
  \begin{lstlisting}
    data Bool = False | True  

  \end{lstlisting}
  Этот тип распадается на два конструктора значений (value constructors), экземпляр значения типа Bool может являться одним из возможных значений (True или False).
\end{description}

\begin{description}
  \item[Пример] 
  Теперь рассмотрим тип-произведение и пример создание константы этого типа: 
  \begin{lstlisting}
    data Person = Person {
      firstName :: String
      , lastName :: String
      , age :: Int

    --Usage
    let p = Person {firstName="John", 
                    lastName="Lennon", 
                    age=43}
  \end{lstlisting}
\end{description}

Алгебраические типы данных могут быть параметризованы -- это позволяет создавать, например, полиморфные контейнеры.

\begin{description}
  \item[Пример] 
  Рассмотрим определение списка, аналогичное определению из стандартной библиотеки языка Haskell:
  \begin{lstlisting}
    data List a = Nil | Cons a (List a)
  \end{lstlisting}
  Здесь List является конструктором типа (type constructor) с одним типовым параметром, а Nil и Cons --- конструкторами значений. Стоит также заметить, что List является рекурсивным типом.
\end{description}

\subsection{Классы типов}

Классы типов позволяют накладывать ограничения на параметрически полиморфные типы, определяя некоторый набор операций, которые могут производиться над типами, принадлежащими к этому классу. Иными словами, класс типов определяет интерфейс, через который можно взаимодействовать с типом.

\begin{description}
  \item[Пример] 
  Рассмотрим определение стандартного класса типов языка Haskell, отвечающего за возможность сравнения на равенство:
  \begin{lstlisting}
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
  \end{lstlisting}
\end{description}

Чтобы воспользоваться возможностями класса типов для какого-то конкретного типа не обходимо объявить этот тип экземпляром класса типов, во многих случаях это может быть сделано неявно, благодаря автоматическому порождению экземпляров в компиляторе GHC

\begin{description}
  \item[Пример] 
  Возможность автоматического порождения экземпляра нужного класса типов для алгебраического типа данных:
  \begin{lstlisting}
    data Numbers = One | Two | Three 
      deriving (Eq)
  \end{lstlisting}
\end{description}

В некоторых случаях необходимо описать экземпляр явно, такая возможность тоже существует.

\begin{description}
  \item[Пример] 
  Явное описание экземпляра:
  \begin{lstlisting}
    data Foo = Foo {x :: Integer, str :: String}
 
    instance Eq Foo where
      (Foo x1 str1) == (Foo x2 str2) = (x1 == x2) && 
                                       (str1 == str2)
  \end{lstlisting}
\end{description}

\chapter{Классический подход к построению монады Parser}

\chapter{Построение монады Parser как комбинации более простых монад}

\chapter{Реализация парсера языка Markdown} 

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
