% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

% Выделение красным для TODO в pdf 
\newcommand\todo[1]{\textcolor{red}{#1}} 

 % Временный сепоратор для разделов введения, должен выглядеть устрашающе
\newcommand\sep{\rule{4cm}{0.4pt}}

% Рамочка вокруг фигур
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\begin{document}

\Intro
В данной работе рассматривается задача синтаксического анализа
файлов в формате Markdown с применением технологий функционального
программирования. В качестве языка реализации используется Haskell.
Синтаксический анализ текстов, таких как, например, исходные коды на языках программирования --- задача,поставленная ещё на самых ранних этапах развития информатики. Традиционные методы решения этой задачи, описанные, например, в книге~\autocite{DragonBook2}, используют императивный подход. 

\section{Предварительные сведения}

\subsection{Особенности императивного подхода}

Что-то про императивный подход

В этой работе используются методы функционального подхода к программированию, одними из основных достоинств которого является высокий уровень абстракции и большая информативность кода.

\subsection{Использованные в работе технологии фукционального программирования}

Функциональное программирование --- парадигма программирования, стиль построения структуры и элементов компьютерных программ, которая трактует вычисления как вычисление значения некоторой математической функции и избегает изменяемого состояния.

Корни функционального программирования уходят в $\lambda$-исчисление, формальную систему, разработанную в 1930-х годах для решения Entscheidungsproblem~\autocite{Entscheidungsproblem}.

Одним из главных преимуществ функциональных языков программирования считается высокий уровень абстракции,большая выразительность и высокий коэффициент повторного использования кода. Для достижения этих свойств в языках реализуются такие средства как параметрический полиморфизм, функции высших порядков, алгебраические типы данных, классы типов и некоторые другие. Использование неизменяемых явно данных позволяет существенно упростить распараллеливание программ. 

\subsubsection{Функции высших порядков}
Ключевой концепцией функционального программирования являются так называемые функции высших порядков (higher-order function). Они представляют собой функции, в качестве параметров которых могут выступать другие функции. 

\begin{description}
  \item[Пример] 
  Рассмотрим одну из функций стандартной библиотеки языка Haskell: 
  \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]

    ghci> map (+3) [1,5,3,1,6]  
    [4,8,6,4,9]
  \end{lstlisting}
  Как видно из типовой аннотации, она принимает на вход функцию, преобразующую значение типа a к значению типа b, и список значений типа b, возвращаемым значением является список результатов применения функции к значениям из входного списка.  
\end{description}

Функция, рассмотренная в примере, обладает ценным свойством: она является полиморфной по своему параметру и выходному значению. Возможность написания параметрически полиморфных функций позволяет при программировании на Haskell повысить повторное использование кода и выразительность, чему способствует также простота синтаксиса, применяемого для описания таких функций.     

\subsubsection{Алгебраические типы данных}

Алгебраические типы данных --- минималистический, но мощный способ описания типов данных, применяемый в функциональных языках программирования. Выделяют типы-перечисления или типы-суммы -- аналог перечислений enum из императивных языков, и типы-контейнеры или типы-произведения, аналог структур struct или записей record.

\begin{description}
  \item[Пример] 
  Рассмотрим простой тип-сумму, используемый в языке Haskell для представления булевых констант: 
  \begin{lstlisting}
    data Bool = False | True  

  \end{lstlisting}
  Этот тип распадается на два конструктора значений (value constructors), экземпляр значения типа Bool может являться одним из возможных значений (True или False).
\end{description}

\begin{description}
  \item[Пример] 
  Теперь рассмотрим тип-произведение и пример создание константы этого типа: 
  \begin{lstlisting}
    data Person = Person {
      firstName :: String
      , lastName :: String
      , age :: Int
    --Usage
    let p = Person {firstName="John", 
                    lastName="Lennon", 
                    age=43}
  \end{lstlisting}
\end{description}

Алгебраические типы данных могут быть параметризованы -- это позволяет создавать, например, полиморфные контейнеры.

\begin{description}
  \item[Пример] 
  Рассмотрим определение списка, аналогичное определению из стандартной библиотеки языка Haskell:
  \begin{lstlisting}
    data List a = Nil | Cons a (List a)
  \end{lstlisting}
  Здесь List является конструктором типа (type constructor) с одним типовым параметром, а Nil и Cons --- конструкторами значений. Стоит также заметить, что List является рекурсивным типом.
\end{description}

\subsubsection{Классы типов}

Классы типов позволяют накладывать ограничения на параметрически полиморфные типы, определяя некоторый набор операций, которые могут производиться над типами, принадлежащими к этому классу. Иными словами, класс типов определяет интерфейс, через который можно взаимодействовать с типом.

\begin{description}
  \item[Пример] 
  Рассмотрим определение стандартного класса типов языка Haskell, отвечающего за возможность сравнения на равенство:
  \begin{lstlisting}
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
  \end{lstlisting}
\end{description}

Чтобы воспользоваться возможностями класса типов для какого-то конкретного типа не обходимо объявить этот тип экземпляром класса типов, во многих случаях это может быть сделано неявно, благодаря автоматическому порождению экземпляров в компиляторе GHC

\begin{description}
  \item[Пример] 
  Возможность автоматического порождения экземпляра нужного класса типов для алгебраического типа данных:
  \begin{lstlisting}
    data Numbers = One | Two | Three 
      deriving (Eq)
  \end{lstlisting}
\end{description}

В некоторых случаях необходимо описать экземпляр явно, такая возможность тоже существует.

\begin{description}
  \item[Пример] 
  Явное описание экземпляра:
  \begin{lstlisting}
    data Foo = Foo {x :: Integer, str :: String}
 
    instance Eq Foo where
      (Foo x1 str1) == (Foo x2 str2) = (x1 == x2) && 
                                       (str1 == str2)
  \end{lstlisting}
\end{description}

Как уже говорилось ранее, код, написанный на языке программирования Haskell имеет очень высокий уровень абстракции. Далее будут рассмотрены два классы типов, представляющие структуры, введённые в язык Haskell под влиянием исследований в области связи теоретической информатики и теории категорий. Принято считать, что эти структуры представляют хорошую абстракцию для вычислений в смысле. В дальнейшем изложении эти классы типов будут постоянно использоваться для построения парсеров. 

\subsubsection{Функтор}

Рассмотрим определение класса типов Functor из стандартной библиотеки Haskell:

\begin{lstlisting}
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{lstlisting}

Как видно из определения, каждый тип, являющийся функтором, должен предоставлять одну функцию. Сформировались две основные интуитивные трактовки функтора: контейнер, содержащий в себе значения определённого типа и вычисление, которое производится в некотором контексте. Согласно первой из этих трактовок, функция fmap применяет подаваемую ей на вход функцию к значению в контейнере и возвращает изменённое значение, с сохранением структуры контейнера. Если же говорить в терминах вычислительных контекстов, то fmap модифицирует вычисление в контексте, но сам контекст остаётся неизменным.

Упомянутые выше списки языка Haskell являются функторами, для них в качестве fmap можно выбрать функцию map. 

Важно заметить, что не любой тип, для которого определена функция fmap является функтором, необходимо также потребовать выполнения двух уравнений, называемых законами функтора:

\begin{lstlisting}
  fmap id = id
  fmap (g . h) = (fmap g) . (fmap h)
\end{lstlisting}

Здесь id --- тождественная функция, а . --- инфиксный оператор композиции функций. Эти уравнения отражают теоретико-категорное определение функтора как отображения между категориями, сохраняющее единичный морфизм и композицию. В случае Haskell рассматриваются эндофункторы над категорией Hask --- категорией типов языка Haskell.  

\subsubsection{Монада}

\subsection{Существующие библиотеки функциональных парсеров}

\section{Монадические парсеры}

Большая часть содержимого этого раздела является вольным переводом статьи~\autocite{MonParsing}.

В девяностые годы двадцатого века были опубликованы результаты исследований, обсуждающие монадичекую природу функциональных парсеров. Эта особенность парсеров приносит практические плоды: использование монадического комбинатора связывания позволяет удобно строить композиции парсеров. 

Дальнейшее развитие монадического подхода к построению парсеров делает возможным выражение цельной монады для парсера в терминах более фундаментальных монад, что обеспечивает большую модульность архитектуры и позволяет варьировать семантику парсера за счёт изменения внутренней монады стека: создавать недетерменированные парсеры, парсеры, сигнализирующие о некорректности исходного текста, парсеры, генерирующие сообщения об ошибках.

\subsection{Классический подход к построению монады Parser}

Функциональный стиль построения парсеров заключается в том, что парсер представляется функцией, которая принимает на вход строку символов и строит по ней некое абстрактное синтаксическое дерево. Удобно считать, что не каждый парсер полностью потребляет входную строку, это одно из условия для возможности построения результирующего парсера по кусочкам, из примитивных. Также необходимо иметь средства для обработки некорректного входа. Для этого существуют разные подходы: можно сообщать об ошибке разбора, либо заменять неудачу списком успехов~\autocite{WadlerSuccess}. Высказанные пожелания о характеристиках парсера могут быть отражены следующим типом языка Haskell: 

\begin{figure}[h]
\begin{lstlisting}
type Parser a = String -> [(a,String)]
\end{lstlisting}
\caption{Тип Parser}
\end{figure}

Мотивацией для приложения монад к построению парсеров является неудобность композиции немонадических парсеров, приводящая к появлению вложенных кортежей: 

\begin{figure}[h]
\begin{lstlisting}
seq :: Parser a -> Parser b -> Parser (a,b)
p `seq` q = \inp -> [((v,w),inp'') | (v,inp')  <- p inp
                                   , (w,inp'') <- q inp']
\end{lstlisting}
\caption{Комбинатор для построения композиции парсеров}
\end{figure}

В листинге ~\ref{listing:MonadParser} приведён экземпляр класса типов Monad для типа Parser: 

\begin{figure}[t]
  \begin{lstlisting}
instance Monad Parser where
  return t = Parser $ \s -> Just (t, s)
  m >>= k  = Parser $ \s -> do 
                              (u, v) <- parse m s
                              (x, y) <- parse (k u) v
                              return (x, y)
  \end{lstlisting}
  \caption{Зкземпляр Monad для Parser}
  \label{listing:MonadParser}
\end{figure}

Операция \lstinline{>>=}, известная как монадическое связывание (bind), является удобным средством для построения композиции парсеров, её использование позволяет избежать неконтролируемого возникновения вложенных кортежей, за счёт прямой передачи выхода первого парсера на вход второго. 

Приведём простейшие примеры парсеров. 

\begin{figure}[h]
  \begin{lstlisting}
item :: Parser Char
item =  Parser f 
        where f []     = []
              f (x:xs) = [(x,xs)]
  \end{lstlisting}
  \caption{Парсер \lstinline{item} в случае цельной монады}
  \label{listing:ParserItem}
\end{figure}

В листинге~\ref{listing:ParserItem} представлен базовый парсер \lstinline{item}, его задача заключается в отделении одного исмвода от входной строки. Именно его реализация требует активной эксплуатации средств, определяемых конкретным типом, представляющим парсер. Это значит, что реализация парсера \lstinline{item} для цельной монады \lstinline{Parser} отличается от той, что будет уместна в случае использования средств комбинирования монад.

\subsection{Построение монады Parser как комбинации более простых монад}

Рассмотренная в предыдущем подразделе монада \lstinline{Parser} не является едиснтвенным примером монады. В статье~\autocite{WadlerMonads} Philip Wadler приводит примеры типов, имеющих моноидальную структуру. В статье~\autocite{MonParsing} описан способ представить тип из листинга~\ref{listing:MonadParser} в виде комбинации монад~\lstinline{State} и ~\lstinline{[]}, для этого применяется механизм трансформеров монад. 

\subsubsection{Подход с трансформерами монад}

В статье~\autocite{MonadTransformers} впервые описаны объекты, трансформеры монад, которые можно использовать в качестве строительных блоков для построения типов, описывающих вычисления с побочными эффектами. Каждый из трансформеров монад позволяет добавить некоторый вычислительный эффект к внутренней монаде, при этом для результирующего типа также возможно построение экземпляра класса типов~\lstinline{Monad}.

Рассмотрим пример: 

Пример со StateT и переменной.

Далее рассказывать про парсер на трасформерах монад

В конце подраздела перечислить недостатки подхода. 

\subsubsection{Подход с расширяемыми эффектами}

\section{Реализация парсера языка Markdown} 

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
